<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Meta 可视化编辑器</title>

    <!-- 字体图标 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- YAML 解析器 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <!-- 二维码生成库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <style>
        /* ==================== 基础样式 ==================== */
        :root {
            --primary: #4a6ee0;
            --primary-dark: #3a5ed0;
            --primary-light: #6b8af0;
            --secondary: #6c757d;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
            --light: #f8f9fa;
            --dark: #343a40;
            --border: #dee2e6;
            --bg: #f5f7fa;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--dark);
            line-height: 1.6;
        }

        /* ==================== 布局 ==================== */
        .app-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* 左侧侧边栏 */
        .sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* 主内容区 */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: row;
            overflow: hidden;
            background: var(--bg);
            height: 100%;
        }

        /* 左侧编辑区 */
        .editor-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 0;
        }

        /* 可拖动分隔条 */
        .resize-handle {
            width: 6px;
            background: linear-gradient(90deg, transparent 0%, var(--border) 50%, transparent 100%);
            cursor: col-resize;
            flex-shrink: 0;
            transition: background 0.2s;
            position: relative;
        }

        .resize-handle:hover,
        .resize-handle.dragging {
            background: var(--primary);
        }

        .resize-handle::before {
            content: '';
            position: absolute;
            left: -3px;
            right: -3px;
            top: 0;
            bottom: 0;
        }

        /* 右侧预览面板 */
        .preview-panel {
            width: 450px;
            min-width: 280px;
            max-width: 800px;
            background: #1e1e1e;
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .preview-panel-header {
            background: #2d2d2d;
            padding: 15px 20px;
            border-bottom: 1px solid #404040;
            color: #fff;
        }

        .preview-panel-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .preview-panel-hint {
            font-size: 12px;
            color: #888;
            line-height: 1.5;
        }

        .preview-panel-stats {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            font-size: 12px;
            color: #aaa;
        }

        .preview-panel-stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .preview-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .preview-panel-code {
            color: #d4d4d4;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-all;
            margin: 0;
        }

        .preview-panel-actions {
            padding: 15px 20px;
            border-top: 1px solid #404040;
            background: #2d2d2d;
        }

        .preview-update-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4caf50;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .header,
        .editor-tabs {
            flex-shrink: 0;
            z-index: 10;
        }

        .editor-panels {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* ==================== 头部 ==================== */
        .header {
            background: white;
            padding: 15px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--primary);
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        /* ==================== 按钮样式 ==================== */
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--secondary);
            color: white;
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--dark);
        }

        .btn-outline:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .btn-sm {
            padding: 5px 10px;
            font-size: 12px;
        }

        .btn-icon {
            width: 32px;
            height: 32px;
            padding: 0;
            justify-content: center;
        }

        /* ==================== 侧边栏内容 ==================== */
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .section {
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* ==================== 表单元素 ==================== */
        .form-group {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            font-weight: 500;
            color: var(--dark);
        }

        .form-control {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.2s;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(74, 110, 224, 0.1);
        }

        .form-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: white;
            font-size: 14px;
        }

        .form-textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 13px;
            font-family: 'Consolas', monospace;
            resize: vertical;
            min-height: 150px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        /* ==================== 节点列表 ==================== */
        .node-list {
            border: 1px solid var(--border);
            border-radius: 6px;
            overflow: hidden;
            max-height: 300px;
            overflow-y: auto;
        }

        .node-item {
            padding: 12px 15px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .node-item:hover {
            background: var(--light);
        }

        .node-item.selected {
            background: rgba(74, 110, 224, 0.1);
            border-left: 3px solid var(--primary);
        }

        .node-checkbox {
            margin-right: 10px;
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .node-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: white;
        }

        .node-icon.vmess {
            background: #8a2be2;
        }

        .node-icon.vless {
            background: #ff6b6b;
        }

        .node-icon.trojan {
            background: #4ecdc4;
        }

        .node-icon.ss {
            background: #45b7d1;
        }

        .node-icon.ssr {
            background: #f39c12;
        }

        .node-icon.socks5 {
            background: #3498db;
        }

        .node-icon.http {
            background: #9b59b6;
        }

        .node-icon.snell {
            background: #2ecc71;
        }

        .node-icon.wireguard {
            background: #e74c3c;
        }

        .node-icon.hysteria {
            background: #9b59b6;
        }

        .node-icon.hysteria2 {
            background: #34495e;
        }

        .node-icon.tuic {
            background: #1abc9c;
        }

        .node-icon.tuic-v5 {
            background: #16a085;
        }

        .node-info {
            flex: 1;
            min-width: 0;
        }

        .node-name {
            font-weight: 500;
            font-size: 14px;
            margin-bottom: 3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .node-details {
            font-size: 12px;
            color: var(--secondary);
        }

        .latency {
            font-weight: 600;
            margin-left: 5px;
        }

        .latency.low {
            color: var(--success);
        }

        .latency.medium {
            color: var(--warning);
        }

        .latency.high {
            color: var(--danger);
        }

        .latency.timeout {
            color: #95a5a6;
            font-style: italic;
        }

        .node-actions {
            display: flex;
            gap: 5px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .node-item:hover .node-actions {
            opacity: 1;
        }

        /* ==================== 主编辑区 ==================== */
        .editor-tabs {
            display: flex;
            background: white;
            border-bottom: 1px solid var(--border);
            padding: 0 20px;
        }

        .editor-tab {
            padding: 15px 20px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: var(--secondary);
            transition: all 0.2s;
        }

        .editor-tab:hover {
            color: var(--primary);
        }

        .editor-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .editor-panel {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: white;
            margin: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            display: none;
            flex-direction: column;
            /* 移除 height: calc(100% - 40px)，依靠 flex: 1 自动填充 */
        }

        .editor-panel.active {
            display: flex;
        }

        /* ==================== 编辑表单 ==================== */
        .editor-form {
            width: 100%;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-full {
            grid-column: 1 / -1;
        }

        .form-section {
            background: var(--light);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
        }

        .form-section-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* ==================== 协议特定表单 ==================== */
        .protocol-form {
            display: none;
        }

        .protocol-form.active {
            display: block;
        }

        /* ==================== 预览面板 ==================== */
        .preview-container {
            background: #1e1e1e;
            border-radius: 8px;
            overflow: hidden;
        }

        .preview-header {
            background: #2d2d2d;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #404040;
        }

        .preview-panel-content {
            flex: 1;
            overflow: auto;
            background-color: #1e1e1e;
            position: relative;
            /* 更加专业的滚动条 */
            scrollbar-width: thin;
            scrollbar-color: #424242 #1e1e1e;
        }

        .preview-panel-code {
            display: block;
            margin: 0;
            padding: 15px;
            color: #d4d4d4;
            /* VS Code Default Text */
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre;
            /* 不自动换行，保持代码格式 */
            tab-size: 4;
        }

        /* Webkit Scrollbar Styling */
        .preview-panel-content::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        .preview-panel-content::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        .preview-panel-content::-webkit-scrollbar-thumb {
            background-color: #424242;
            border-radius: 6px;
            border: 3px solid #1e1e1e;
        }

        .preview-panel-content::-webkit-scrollbar-thumb:hover {
            background-color: #555;
        }

        .preview-panel-content::-webkit-scrollbar-corner {
            background: #1e1e1e;
        }

        /* ==================== 状态消息 ==================== */
        .status-message {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 6px;
            background: var(--success);
            color: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slideIn 0.3s ease;
            z-index: 1000;
        }

        .status-message.error {
            background: var(--danger);
        }

        .status-message.warning {
            background: var(--warning);
            color: var(--dark);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* ==================== 响应式设计 ==================== */
        @media (max-width: 1024px) {
            .app-container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                height: 300px;
            }

            .form-row {
                grid-template-columns: 1fr;
            }
        }

        /* ==================== 自定义滚动条 ==================== */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* 订阅面板样式 */
        .subs-list-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .sub-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            position: relative;
            transition: all 0.3s ease;
        }

        .sub-card:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: var(--primary-color);
            transform: translateY(-2px);
        }

        .sub-card-title {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 8px;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sub-card-url {
            font-size: 0.85rem;
            color: var(--text-secondary);
            word-break: break-all;
            margin-bottom: 12px;
            opacity: 0.7;
        }

        .sub-card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 10px;
            font-size: 0.8rem;
        }

        .sub-card-actions {
            display: flex;
            gap: 8px;
        }

        .sub-action-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 5px;
            transition: color 0.2s;
        }

        .sub-action-btn:hover {
            color: var(--primary-color);
        }

        .sub-action-btn.delete:hover {
            color: #ff4d4d;
        }

        .preview-panel-code.updated {
            animation: preview-flash 1s ease-out;
        }

        /* 行级高亮动画 */
        @keyframes line-highlight {
            0% {
                background-color: rgba(55, 148, 255, 0.3);
            }

            100% {
                background-color: transparent;
            }
        }

        .code-line {
            min-height: 21px;
            /* 对应 line-height 1.6 * 13px */
            padding: 0 5px;
            /* 给一点左右间距 */
            border-radius: 2px;
        }

        .code-line.flash {
            animation: line-highlight 1.5s ease-out;
        }

        /* YAML 语法高亮 Theme: Dark+ (VS Code like) */
        .y-key {
            color: #9cdcfe;
        }

        /* Light Blue */
        .y-str {
            color: #ce9178;
        }

        /* Orange */
        .y-num {
            color: #b5cea8;
        }

        /* Light Green */
        .y-bool {
            color: #569cd6;
        }

        /* Blue */
        .y-cmt {
            color: #6a9955;
            font-style: italic;
        }

        /* Green */
        .y-anchor {
            color: #c586c0;
        }

        /* Purple */


        /* 行高亮效果 */
        .preview-line-highlight {
            background-color: rgba(255, 235, 59, 0.3) !important;
            transition: background-color 0.5s;
        }

        /* 二维码弹窗样式 */
        .qr-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .qr-modal.show {
            display: flex;
        }

        .qr-modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            text-align: center;
            position: relative;
        }

        .qr-modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--secondary);
            transition: color 0.2s;
        }

        .qr-modal-close:hover {
            color: var(--danger);
        }

        .qr-modal-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--dark);
            margin-bottom: 20px;
        }

        .qr-code-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            padding: 20px;
            background: var(--light);
            border-radius: 8px;
        }

        .qr-modal-hint {
            font-size: 14px;
            color: var(--secondary);
            margin-top: 15px;
        }

        .qr-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .qr-tab {
            padding: 8px 20px;
            border: 2px solid var(--border);
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .qr-tab:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .qr-tab.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .qr-content {
            display: none;
        }

        .qr-content.active {
            display: block;
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- 左侧侧边栏 -->
        <div class="sidebar">
            <div class="header">
                <div class="logo">
                    <i class="fas fa-code-branch"></i>
                    <span>Clash Meta Editor</span>
                </div>
            </div>

            <div class="sidebar-content">
                <!-- 节点列表 -->
                <div class="section">
                    <div class="section-title">
                        <i class="fas fa-server"></i>
                        <span>节点列表 (<span id="nodeCount">0</span>)</span>
                        <div
                            style="margin-left: auto; display: flex; align-items: center; gap: 5px; font-size: 12px; font-weight: normal; color: var(--secondary);">
                            <input type="checkbox" id="selectAllNodes" title="全选/取消全选"> 全选
                        </div>
                    </div>
                    <div class="node-list" id="nodeList">
                        <!-- 节点将动态添加 -->
                        <div style="text-align: center; padding: 30px; color: #6c757d;">
                            <i class="fas fa-cloud" style="font-size: 36px; margin-bottom: 10px;"></i>
                            <p>还没有节点</p>
                            <p style="font-size: 12px; margin-top: 5px;">导入链接后显示</p>
                        </div>
                    </div>
                    <div style="margin-top: 10px; display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button id="addNodeBtn" class="btn btn-primary btn-sm">
                            <i class="fas fa-plus"></i> 添加
                        </button>
                        <button id="deleteSelectedBtn" class="btn btn-outline btn-sm" style="color: var(--danger);">
                            <i class="fas fa-trash-alt"></i> 批量删除
                        </button>
                        <button id="exportLinksBtn" class="btn btn-outline btn-sm">
                            <i class="fas fa-exchange-alt"></i> 转换链接
                        </button>
                        <button id="batchQRCodeBtn" class="btn btn-outline btn-sm" title="批量生成二维码">
                            <i class="fas fa-qrcode"></i> 批量二维码
                        </button>
                    </div>
                    <div style="margin-top: 8px; display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button id="testLatencyBtn" class="btn btn-outline btn-sm"
                            title="使用 External Controller 检测真实延迟">
                            <i class="fas fa-tachometer-alt"></i> 显示延迟
                        </button>
                        <button id="testConnectivityBtn" class="btn btn-outline btn-sm" title="检测 Google/Youtube 等连通性">
                            <i class="fas fa-satellite-dish"></i> 连通性测试
                        </button>
                    </div>
                    <div id="nodeTypeStats"
                        style="margin-top: 10px; font-size: 12px; color: #888; display: flex; flex-wrap: wrap; gap: 8px;">
                        <!-- 节点类型统计将在这里动态显示 -->
                    </div>
                </div>

                <!-- 链接导入 -->
                <div class="section">
                    <div class="section-title">
                        <i class="fas fa-link"></i>
                        <span>链接导入</span>
                    </div>
                    <div class="form-group">
                        <label class="form-label">协议链接（支持所有 Meta 协议及订阅链接）</label>
                        <textarea id="importLinks" class="form-textarea" placeholder="在此粘贴：
1. 协议链接：vmess://, vless://, ss://, trojan://, hy2:// 等
2. 订阅链接：http:// 或 https:// 开头的链接
3. 订阅内容：Base64 编码或 Clash YAML 格式内容"></textarea>
                    </div>
                    <button id="parseLinksBtn" class="btn btn-primary" style="width: 100%;">
                        <i class="fas fa-code"></i> 解析所有链接
                    </button>
                </div>

                <!-- 快捷配置 -->
                <div class="section">
                    <div class="section-title">
                        <i class="fas fa-bolt"></i>
                        <span>快速设置</span>
                    </div>
                    <div class="form-group">
                        <label class="form-label">运行模式</label>
                        <select id="sidebarProxyMode" class="form-select"
                            onchange="document.getElementById('proxyMode').value = this.value">
                            <option value="rule">规则模式 (Rule)</option>
                            <option value="global">全局模式 (Global)</option>
                            <option value="direct">直连模式 (Direct)</option>
                        </select>
                    </div>
                    <div style="font-size: 11px; color: #6c757d; margin-top: 10px;">
                        <i class="fas fa-info-circle"></i> 更多高级选项请前往“基础设置”面板。
                    </div>
                </div>
            </div>
        </div>

        <!-- 主内容区 -->
        <div class="main-content">
            <!-- 左侧编辑区 -->
            <div class="editor-content">
                <div class="header">
                    <!-- 顶部按钮已移除，功能整合至预览面板 -->
                </div>

                <!-- 编辑标签页 -->
                <div class="editor-tabs">
                    <button class="editor-tab active" data-tab="general">基础设置</button>
                    <button class="editor-tab" data-tab="proxy">代理设置</button>
                    <button class="editor-tab" data-tab="dns">DNS设置</button>
                    <button class="editor-tab" data-tab="rules">规则管理</button>
                    <button class="editor-tab" data-tab="sub-manager">订阅管理</button>
                    <button class="editor-tab" data-tab="batch-tools">批量工具</button>
                    <button class="editor-tab" data-tab="tun">TUN设置</button>
                    <button class="editor-tab" data-tab="script">脚本设置</button>
                </div>

                <!-- 编辑面板 -->
                <div class="editor-panels">
                    <!-- 基础设置面板 -->
                    <div id="general-panel" class="editor-panel active">
                        <div class="editor-form">
                            <div class="form-section">
                                <div class="form-section-title">
                                    <i class="fas fa-network-wired"></i>
                                    网络与核心设置
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label">混合端口 (mixed-port)</label>
                                        <input type="number" id="mixedPort" class="form-control" value="7890" min="1"
                                            max="65535">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">外部控制器 (external-controller)</label>
                                        <input type="text" id="externalController" class="form-control"
                                            value="127.0.0.1:9090">
                                    </div>
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label">日志等级 (log-level)</label>
                                        <select id="logLevel" class="form-select">
                                            <option value="info">info</option>
                                            <option value="warning">warning</option>
                                            <option value="error">error</option>
                                            <option value="debug">debug</option>
                                            <option value="silent">silent</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">运行模式 (mode)</label>
                                        <select id="proxyMode" class="form-select">
                                            <option value="rule">rule (按规则)</option>
                                            <option value="global">global (全局)</option>
                                            <option value="direct">direct (直连)</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="form-row" style="margin-top: 15px;">
                                    <div class="checkbox-group">
                                        <input type="checkbox" id="allowLan" checked>
                                        <label for="allowLan">允许局域网 (allow-lan)</label>
                                    </div>
                                    <div class="checkbox-group">
                                        <input type="checkbox" id="ipv6" checked>
                                        <label for="ipv6">启用 IPv6</label>
                                    </div>
                                </div>
                                <div class="form-row">
                                    <div class="checkbox-group">
                                        <input type="checkbox" id="unifiedDelay">
                                        <label for="unifiedDelay">统一延迟 (unified-delay)</label>
                                    </div>
                                    <div class="checkbox-group">
                                        <input type="checkbox" id="tcpConcurrent" checked>
                                        <label for="tcpConcurrent">TCP 并发 (tcp-concurrent)</label>
                                    </div>
                                </div>
                            </div>

                            <div class="form-section">
                                <div class="form-section-title">
                                    <i class="fas fa-database"></i>
                                    数据与处理模式
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label">进程匹配模式 (find-process-mode)</label>
                                        <select id="findProcessMode" class="form-select">
                                            <option value="strict">strict (严格)</option>
                                            <option value="always">always (始终)</option>
                                            <option value="off">off (关闭)</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">全局指纹 (global-client-fingerprint)</label>
                                        <input type="text" id="globalClientFingerprint" class="form-control"
                                            value="chrome">
                                    </div>
                                </div>
                                <div class="form-row" style="margin-top: 15px;">
                                    <div class="checkbox-group">
                                        <input type="checkbox" id="geodataMode" checked>
                                        <label for="geodataMode">Geodata 模式</label>
                                    </div>
                                    <div class="checkbox-group">
                                        <input type="checkbox" id="storeSelected" checked>
                                        <label for="storeSelected">持久化选择 (store-selected)</label>
                                    </div>
                                    <div class="checkbox-group">
                                        <input type="checkbox" id="storeFakeIp" checked>
                                        <label for="storeFakeIp">持久化 Fake-IP</label>
                                    </div>
                                </div>
                                <div class="form-group" style="margin-top: 15px;">
                                    <label class="form-label">GeoX 数据库 URL (geoip / geosite / mmdb)</label>
                                    <input type="text" id="geoxGeoip" class="form-control"
                                        value="https://fastly.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geoip.dat"
                                        style="margin-bottom:5px;">
                                    <input type="text" id="geoxGeosite" class="form-control"
                                        value="https://fastly.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geosite.dat"
                                        style="margin-bottom:5px;">
                                    <input type="text" id="geoxMmdb" class="form-control"
                                        value="https://fastly.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/country.mmdb">
                                </div>
                            </div>

                            <div class="form-section">
                                <div class="form-section-title">
                                    <i class="fas fa-search"></i>
                                    流量探测 (Sniffer)
                                </div>
                                <div class="checkbox-group">
                                    <input type="checkbox" id="snifferEnable" checked>
                                    <label for="snifferEnable">启用探测</label>
                                </div>
                                <div class="form-row" style="margin-top: 10px;">
                                    <div class="form-group">
                                        <label class="form-label">TLS 探测端口</label>
                                        <input type="text" id="snifferTlsPorts" class="form-control" value="443, 8443">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">HTTP 探测端口</label>
                                        <input type="text" id="snifferHttpPorts" class="form-control"
                                            value="80, 8080-8880">
                                    </div>
                                </div>
                                <div class="checkbox-group">
                                    <input type="checkbox" id="snifferOverrideDestination" checked>
                                    <label for="snifferOverrideDestination">覆盖目标地址 (override-destination)</label>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 代理设置面板 -->
                    <div id="proxy-panel" class="editor-panel">
                        <div class="editor-form">
                            <!-- 当前编辑的节点 -->
                            <div id="currentNodeEditor" style="display: none;">
                                <div class="form-section">
                                    <div class="form-section-title" id="editingNodeTitle">
                                        <i class="fas fa-edit"></i>
                                        编辑节点
                                    </div>

                                    <!-- 基础信息 -->
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">节点名称</label>
                                            <input type="text" id="editNodeName" class="form-control">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">协议类型</label>
                                            <select id="editNodeType" class="form-select">
                                                <!-- 基础协议 -->
                                                <option value="vmess">VMess</option>
                                                <option value="vless">VLESS</option>
                                                <option value="trojan">Trojan</option>
                                                <option value="ss">Shadowsocks</option>
                                                <option value="ssr">ShadowsocksR</option>
                                                <option value="socks5">SOCKS5</option>
                                                <option value="http">HTTP</option>

                                                <!-- 现代协议 -->
                                                <option value="snell">Snell</option>
                                                <option value="wireguard">WireGuard</option>
                                                <option value="hysteria">Hysteria</option>
                                                <option value="hysteria2">Hysteria2</option>
                                                <option value="tuic">TUIC</option>
                                                <option value="tuic-v5">TUIC v5</option>
                                            </select>
                                        </div>
                                    </div>

                                    <!-- 服务器信息 -->
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">服务器地址</label>
                                            <input type="text" id="editNodeServer" class="form-control">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">端口</label>
                                            <input type="number" id="editNodePort" class="form-control" min="1"
                                                max="65535">
                                        </div>
                                    </div>
                                    <div class="checkbox-group" style="margin-top: 10px;">
                                        <input type="checkbox" id="editNodeUdp" checked>
                                        <label for="editNodeUdp">启用 UDP 转发</label>
                                    </div>

                                    <!-- VMess 表单 -->
                                    <div id="vmess-form" class="protocol-form">
                                        <div class="form-row">
                                            <div class="form-group">
                                                <label class="form-label">UUID</label>
                                                <input type="text" id="editVmessUuid" class="form-control"
                                                    placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx">
                                            </div>
                                            <div class="form-group">
                                                <label class="form-label">AlterId</label>
                                                <input type="number" id="editVmessAlterId" class="form-control"
                                                    value="0">
                                            </div>
                                        </div>
                                        <div class="form-row">
                                            <div class="form-group">
                                                <label class="form-label">加密方式</label>
                                                <select id="editVmessCipher" class="form-select">
                                                    <option value="auto">auto</option>
                                                    <option value="none">none</option>
                                                    <option value="aes-128-gcm">aes-128-gcm</option>
                                                    <option value="chacha20-poly1305">chacha20-poly1305</option>
                                                </select>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- VLESS 表单 -->
                                    <div id="vless-form" class="protocol-form">
                                        <div class="form-row">
                                            <div class="form-group">
                                                <label class="form-label">UUID</label>
                                                <input type="text" id="editVlessUuid" class="form-control"
                                                    placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx">
                                            </div>
                                            <div class="form-group">
                                                <label class="form-label">流控</label>
                                                <select id="editVlessFlow" class="form-select">
                                                    <option value="">无</option>
                                                    <option value="xtls-rprx-vision">xtls-rprx-vision</option>
                                                    <option value="xtls-rprx-vision-udp443">xtls-rprx-vision-udp443
                                                    </option>
                                                </select>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Trojan 表单 -->
                                    <div id="trojan-form" class="protocol-form">
                                        <div class="form-row">
                                            <div class="form-group">
                                                <label class="form-label">密码</label>
                                                <input type="text" id="editTrojanPassword" class="form-control"
                                                    placeholder="trojan密码">
                                            </div>
                                        </div>
                                        <div class="info-alert">
                                            Trojan 协议强制开启 TLS。请在下方的“TLS 设置”中配置 SNI、ALPN 和指纹。
                                        </div>
                                    </div>

                                    <!-- Shadowsocks 表单 -->
                                    <div id="ss-form" class="protocol-form">
                                        <div class="form-row">
                                            <label class="form-label">加密方式</label>
                                            <select id="editSsCipher" class="form-select">
                                                <option value="aes-256-gcm">aes-256-gcm</option>
                                                <option value="chacha20-ietf-poly1305">chacha20-ietf-poly1305
                                                </option>
                                                <option value="2022-blake3-aes-256-gcm">2022-blake3-aes-256-gcm
                                                </option>
                                                <option value="2022-blake3-chacha20-poly1305">
                                                    2022-blake3-chacha20-poly1305</option>
                                                <option value="xchacha20-ietf-poly1305">xchacha20-ietf-poly1305
                                                </option>
                                            </select>
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">密码</label>
                                            <input type="text" id="editSsPassword" class="form-control"
                                                placeholder="shadowsocks密码">
                                        </div>
                                    </div>
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">插件</label>
                                            <input type="text" id="editSsPlugin" class="form-control"
                                                placeholder="obfs/v2ray-plugin">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">插件参数</label>
                                            <input type="text" id="editSsPluginOpts" class="form-control"
                                                placeholder="plugin options">
                                        </div>
                                    </div>
                                </div>

                                <!-- SSR 表单 -->
                                <div id="ssr-form" class="protocol-form">
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">加密方式</label>
                                            <select id="editSsrCipher" class="form-select">
                                                <option value="aes-256-cfb">aes-256-cfb</option>
                                                <option value="aes-128-cfb">aes-128-cfb</option>
                                                <option value="chacha20">chacha20</option>
                                                <option value="chacha20-ietf">chacha20-ietf</option>
                                                <option value="xchacha20">xchacha20</option>
                                            </select>
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">密码</label>
                                            <input type="text" id="editSsrPassword" class="form-control"
                                                placeholder="ssr密码">
                                        </div>
                                    </div>
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">协议</label>
                                            <select id="editSsrProtocol" class="form-select">
                                                <option value="origin">origin</option>
                                                <option value="auth_sha1_v4">auth_sha1_v4</option>
                                                <option value="auth_aes128_md5">auth_aes128_md5</option>
                                                <option value="auth_aes128_sha1">auth_aes128_sha1</option>
                                                <option value="auth_chain_a">auth_chain_a</option>
                                                <option value="auth_chain_b">auth_chain_b</option>
                                            </select>
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">协议参数</label>
                                            <input type="text" id="editSsrProtocolParam" class="form-control"
                                                placeholder="protocol params">
                                        </div>
                                    </div>
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">混淆</label>
                                            <select id="editSsrObfs" class="form-select">
                                                <option value="plain">plain</option>
                                                <option value="http_simple">http_simple</option>
                                                <option value="http_post">http_post</option>
                                                <option value="tls1.2_ticket_auth">tls1.2_ticket_auth</option>
                                                <option value="tls1.2_ticket_fastauth">tls1.2_ticket_fastauth
                                                </option>
                                            </select>
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">混淆参数</label>
                                            <input type="text" id="editSsrObfsParam" class="form-control"
                                                placeholder="obfs params">
                                        </div>
                                    </div>
                                </div>

                                <!-- Hysteria 表单 -->
                                <div id="hysteria-form" class="protocol-form">
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">协议版本</label>
                                            <select id="editHysteriaVersion" class="form-select">
                                                <option value="1">Hysteria 1</option>
                                                <option value="2">Hysteria 2</option>
                                            </select>
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">密码</label>
                                            <input type="text" id="editHysteriaPassword" class="form-control"
                                                placeholder="auth password">
                                        </div>
                                    </div>
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">上行速度</label>
                                            <input type="text" id="editHysteriaUp" class="form-control"
                                                placeholder="100 Mbps">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">下行速度</label>
                                            <input type="text" id="editHysteriaDown" class="form-control"
                                                placeholder="100 Mbps">
                                        </div>
                                    </div>
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">OBFS</label>
                                            <input type="text" id="editHysteriaObfs" class="form-control"
                                                placeholder="obfs password">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">ALPN</label>
                                            <input type="text" id="editHysteriaAlpn" class="form-control"
                                                placeholder="h3">
                                        </div>
                                    </div>
                                </div>

                                <!-- TUIC 表单 -->
                                <div id="tuic-form" class="protocol-form">
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">协议版本</label>
                                            <select id="editTuicVersion" class="form-select">
                                                <option value="5">TUIC v5</option>
                                                <option value="4">TUIC v4</option>
                                            </select>
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">UUID</label>
                                            <input type="text" id="editTuicUuid" class="form-control"
                                                placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx">
                                        </div>
                                    </div>
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">密码</label>
                                            <input type="text" id="editTuicPassword" class="form-control"
                                                placeholder="password">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">SNI</label>
                                            <input type="text" id="editTuicSni" class="form-control"
                                                placeholder="server name">
                                        </div>
                                    </div>
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">ALPN</label>
                                            <input type="text" id="editTuicAlpn" class="form-control" placeholder="h3">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">UDP 转发</label>
                                            <select id="editTuicUdpRelay" class="form-select">
                                                <option value="true">启用</option>
                                                <option value="false">禁用</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>

                                <!-- Snell 表单 -->
                                <div id="snell-form" class="protocol-form">
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">密码</label>
                                            <input type="text" id="editSnellPassword" class="form-control"
                                                placeholder="password">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">PSK</label>
                                            <input type="text" id="editSnellPsk" class="form-control"
                                                placeholder="pre-shared key">
                                        </div>
                                    </div>
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">版本</label>
                                            <input type="number" id="editSnellVersion" class="form-control" value="2"
                                                min="1" max="4">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">OBFS</label>
                                            <select id="editSnellObfs" class="form-select">
                                                <option value="none">none</option>
                                                <option value="http">http</option>
                                                <option value="tls">tls</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>

                                <!-- WireGuard 表单 -->
                                <div id="wireguard-form" class="protocol-form">
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">私钥</label>
                                            <input type="text" id="editWgPrivateKey" class="form-control"
                                                placeholder="private key">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">公钥</label>
                                            <input type="text" id="editWgPublicKey" class="form-control"
                                                placeholder="peer public key">
                                        </div>
                                    </div>
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">预共享密钥</label>
                                            <input type="text" id="editWgPreSharedKey" class="form-control"
                                                placeholder="pre-shared key">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">本地地址</label>
                                            <input type="text" id="editWgLocalAddress" class="form-control"
                                                placeholder="10.0.0.2/32">
                                        </div>
                                    </div>
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">DNS</label>
                                            <input type="text" id="editWgDns" class="form-control"
                                                placeholder="1.1.1.1">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">MTU</label>
                                            <input type="number" id="editWgMtu" class="form-control" value="1420">
                                        </div>
                                    </div>
                                </div>

                                <!-- HTTP/SOCKS5 表单 -->
                                <div id="socks-form" class="protocol-form">
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">用户名</label>
                                            <input type="text" id="editSocksUsername" class="form-control"
                                                placeholder="username">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">密码</label>
                                            <input type="text" id="editSocksPassword" class="form-control"
                                                placeholder="password">
                                        </div>
                                    </div>
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">TLS</label>
                                            <select id="editSocksTls" class="form-select">
                                                <option value="false">禁用</option>
                                                <option value="true">启用</option>
                                            </select>
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">跳过证书验证</label>
                                            <select id="editSocksSkipVerify" class="form-select">
                                                <option value="false">否</option>
                                                <option value="true">是</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>

                                <!-- TLS设置 -->
                                <div class="form-section">
                                    <div class="form-section-title">
                                        <i class="fas fa-lock"></i>
                                        TLS/Reality 设置
                                    </div>
                                    <div class="checkbox-group">
                                        <input type="checkbox" id="editNodeTls">
                                        <label for="editNodeTls">启用 TLS</label>
                                    </div>
                                    <div class="checkbox-group">
                                        <input type="checkbox" id="editNodeEch">
                                        <label for="editNodeEch">启用 ECH</label>
                                    </div>
                                    <div class="checkbox-group">
                                        <input type="checkbox" id="editNodeReality">
                                        <label for="editNodeReality">启用 Reality</label>
                                    </div>
                                    <div class="form-row" id="tlsSettings" style="display: none;">
                                        <div class="form-group">
                                            <label class="form-label">SNI</label>
                                            <input type="text" id="editNodeSni" class="form-control">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">ALPN</label>
                                            <input type="text" id="editNodeAlpn" class="form-control"
                                                placeholder="h2,http/1.1">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">Fingerprint</label>
                                            <input type="text" id="editNodeFingerprint" class="form-control"
                                                placeholder="chrome/firefox/safari">
                                        </div>
                                        <div class="checkbox-group">
                                            <input type="checkbox" id="editNodeSkipVerify">
                                            <label for="editNodeSkipVerify">跳过证书验证</label>
                                        </div>
                                        <div class="form-group" id="echSettings"
                                            style="display: none; width: 100%; margin-top: 10px;">
                                            <label class="form-label">ECH 配置 (Domain+DNS 或 Base64)</label>
                                            <input type="text" id="editNodeEchCode" class="form-control"
                                                placeholder="cloudflare-ech.com+https://dns.alidns.com/dns-query">
                                        </div>
                                    </div>
                                    <div class="form-row" id="realitySettings" style="display: none;">
                                        <div class="form-group">
                                            <label class="form-label">公钥</label>
                                            <input type="text" id="editNodeRealityPbk" class="form-control">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">短ID</label>
                                            <input type="text" id="editNodeRealitySid" class="form-control">
                                        </div>
                                    </div>
                                </div>

                                <!-- 传输设置 -->
                                <div class="form-section">
                                    <div class="form-section-title">
                                        <i class="fas fa-exchange-alt"></i>
                                        传输设置
                                    </div>
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">传输协议</label>
                                            <select id="editNodeNetwork" class="form-select">
                                                <option value="tcp">tcp</option>
                                                <option value="ws">websocket</option>
                                                <option value="h2">http/2</option>
                                                <option value="grpc">gRPC</option>
                                                <option value="http">HTTP</option>
                                                <option value="quic">QUIC</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div id="wsSettings" style="display: none;">
                                        <div class="form-row">
                                            <div class="form-group">
                                                <label class="form-label">WebSocket路径</label>
                                                <input type="text" id="editWsPath" class="form-control" value="/">
                                            </div>
                                            <div class="form-group">
                                                <label class="form-label">Host头</label>
                                                <input type="text" id="editWsHost" class="form-control">
                                            </div>
                                        </div>
                                    </div>
                                    <div id="grpcSettings" style="display: none;">
                                        <div class="form-row">
                                            <div class="form-group">
                                                <label class="form-label">gRPC服务名</label>
                                                <input type="text" id="editGrpcServiceName" class="form-control"
                                                    value="GunService">
                                            </div>
                                            <div class="form-group">
                                                <label class="form-label">模式</label>
                                                <select id="editGrpcMode" class="form-select">
                                                    <option value="gun">gun</option>
                                                    <option value="multi">multi</option>
                                                </select>
                                            </div>
                                        </div>
                                    </div>
                                    <div id="httpSettings" style="display: none;">
                                        <div class="form-row">
                                            <div class="form-group">
                                                <label class="form-label">伪装路径 (Path)</label>
                                                <input type="text" id="editHttpPath" class="form-control" value="/">
                                            </div>
                                            <div class="form-group">
                                                <label class="form-label">伪装域名 (Host)</label>
                                                <input type="text" id="editHttpHost" class="form-control">
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div style="display: flex; gap: 10px; margin-top: 20px;">
                                    <button type="button" id="saveNodeBtn" class="btn btn-primary">
                                        <i class="fas fa-save"></i> 保存节点
                                    </button>
                                    <button type="button" id="cancelEditBtn" class="btn btn-outline">
                                        取消
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- 策略组设置 -->
                        <div class="form-section" id="proxyGroupsSection">
                            <div class="form-section-title">
                                <i class="fas fa-layer-group"></i>
                                策略组设置
                            </div>
                            <div id="proxyGroupsList">
                                <!-- 策略组将动态添加 -->
                            </div>
                            <button type="button" id="addProxyGroupBtn" class="btn btn-outline"
                                style="margin-top: 10px;">
                                <i class="fas fa-plus"></i> 添加策略组
                            </button>
                        </div>
                    </div>

                    <!-- DNS设置面板 -->
                    <div id="dns-panel" class="editor-panel">
                        <div class="editor-form">
                            <div class="form-section">
                                <div class="form-section-title">
                                    <i class="fas fa-globe"></i>
                                    DNS 设置核心
                                </div>
                                <div class="checkbox-group">
                                    <input type="checkbox" id="dnsEnable" checked>
                                    <label for="dnsEnable">启用 DNS 解析</label>
                                </div>
                                <div class="form-row" style="margin-top:10px;">
                                    <div class="form-group">
                                        <label class="form-label">监听地址</label>
                                        <input type="text" id="dnsListen" class="form-control" value=":1053">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Fake-IP 范围</label>
                                        <input type="text" id="dnsFakeIpRange" class="form-control" value="28.0.0.1/8">
                                    </div>
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label">增强模式</label>
                                        <select id="dnsEnhancedMode" class="form-select">
                                            <option value="fake-ip">Fake-IP</option>
                                            <option value="redir-host">Redir-Host</option>
                                        </select>
                                    </div>
                                    <div class="checkbox-group" style="padding-top: 35px;">
                                        <input type="checkbox" id="dnsIpv6" checked>
                                        <label for="dnsIpv6">启用 IPv6</label>
                                    </div>
                                </div>
                            </div>

                            <div class="form-section">
                                <div class="form-section-title">
                                    <i class="fas fa-server"></i>
                                    DNS 服务器列表
                                </div>
                                <div class="form-group">
                                    <label class="form-label">默认 Nameservers (default-nameserver)</label>
                                    <textarea id="dnsDefaultNameserver" class="form-textarea"
                                        rows="2">223.5.5.5</textarea>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">主要 Nameservers</label>
                                    <textarea id="dnsNameservers" class="form-textarea" rows="3">tls://8.8.4.4#dns
tls://1.0.0.1#dns</textarea>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">代理服务器专用 DNS (proxy-server-nameserver)</label>
                                    <textarea id="dnsProxyServerNameserver" class="form-textarea"
                                        rows="2">https://doh.pub/dns-query</textarea>
                                </div>
                            </div>

                            <div class="form-section">
                                <div class="form-section-title">
                                    <i class="fas fa-filter"></i>
                                    DNS 高级设置
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Fake-IP 过滤器 (fake-ip-filter)</label>
                                    <textarea id="dnsFakeIpFilter" class="form-textarea" rows="3">*
+.lan
+.local</textarea>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">分流策略 (nameserver-policy)</label>
                                    <textarea id="dnsNameserverPolicy" class="form-textarea"
                                        rows="3">"geosite:cn,private": ["https://doh.pub/dns-query", "https://dns.alidns.com/dns-query"]</textarea>
                                    <small style="color: #6c757d; font-size: 12px;">使用 JSON 格式对象: "域名": ["DNS1",
                                        "DNS2"]</small>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 规则管理面板 -->
                    <div id="rules-panel" class="editor-panel">
                        <div class="editor-form">
                            <div class="form-section">
                                <div class="form-section-title">
                                    <i class="fas fa-gavel"></i>
                                    规则管理
                                </div>
                                <div class="form-group">
                                    <label class="form-label">自定义规则</label>
                                    <textarea id="customRules" class="form-textarea" rows="10"># 基础规则
DOMAIN-SUFFIX,google.com,proxy
DOMAIN-KEYWORD,github,proxy
DOMAIN-SUFFIX,openai.com,proxy
DOMAIN-SUFFIX,netflix.com,proxy
DOMAIN-SUFFIX,youtube.com,proxy
DOMAIN-SUFFIX,twitter.com,proxy
DOMAIN-SUFFIX,facebook.com,proxy

# 国内直连
DOMAIN-SUFFIX,baidu.com,DIRECT
DOMAIN-SUFFIX,qq.com,DIRECT
DOMAIN-SUFFIX,weibo.com,DIRECT
DOMAIN-SUFFIX,taobao.com,DIRECT
DOMAIN-SUFFIX,jd.com,DIRECT

# 局域网和私有网络
IP-CIDR,10.0.0.0/8,DIRECT
IP-CIDR,127.0.0.0/8,DIRECT
IP-CIDR,172.16.0.0/12,DIRECT
IP-CIDR,192.168.0.0/16,DIRECT
IP-CIDR,169.254.0.0/16,DIRECT

# 中国IP直连
GEOIP,CN,DIRECT

# 最终规则
MATCH,others</textarea>
                                </div>
                                <div style="display: flex; gap: 10px; margin-top: 10px;">
                                    <button type="button" id="addRuleBtn" class="btn btn-primary">
                                        <i class="fas fa-plus"></i> 添加规则
                                    </button>
                                    <button type="button" id="clearRulesBtn" class="btn btn-outline">
                                        <i class="fas fa-trash"></i> 清空规则
                                    </button>
                                    <button type="button" id="importRulesBtn" class="btn btn-outline">
                                        <i class="fas fa-file-import"></i> 导入规则
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 订阅管理面板 -->
                    <div id="sub-manager-panel" class="editor-panel">
                        <div class="editor-form">
                            <div class="form-section">
                                <div class="form-section-title">
                                    <i class="fas fa-rss"></i>
                                    订阅源管理 (Sub-Store 风格)
                                </div>
                                <div class="form-help-text"
                                    style="margin-bottom: 15px; color: var(--text-secondary); font-size: 0.9rem;">
                                    保存您的订阅链接，支持一键合并更新所有节点。
                                </div>
                                <div class="button-group" style="margin-bottom: 20px;">
                                    <button type="button" id="addSubBtn" class="btn btn-primary">
                                        <i class="fas fa-plus"></i> 添加订阅源
                                    </button>
                                    <button type="button" id="updateAllSubsBtn" class="btn btn-outline">
                                        <i class="fas fa-sync-alt"></i> 更新所有订阅
                                    </button>
                                    <button type="button" id="resetAllSubsBtn" class="btn btn-outline"
                                        style="color: var(--danger); border-color: var(--danger);">
                                        <i class="fas fa-redo"></i> 重置状态
                                    </button>
                                </div>
                                <div id="subsListContainer" class="subs-list-grid">
                                    <!-- 订阅卡片动态生成 -->
                                    <div class="empty-state">
                                        <i class="fas fa-folder-open"></i>
                                        <p>暂无保存的订阅源</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 批量工具面板 -->
                    <div id="batch-tools-panel" class="editor-panel">
                        <div class="editor-form">
                            <div class="form-section">
                                <div class="form-section-title">
                                    <i class="fas fa-magic"></i>
                                    批量自动化处理
                                </div>
                                <div class="form-group">
                                    <label class="form-label">统一前缀 (例如: ✈️ 机场A | )</label>
                                    <input type="text" id="batchPrefix" class="form-control" placeholder="留空则不添加">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">统一后缀 (例如: [1x])</label>
                                    <input type="text" id="batchSuffix" class="form-control" placeholder="留空则不添加">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">节点名称重命名 (正则替换: 匹配内容|替换内容)</label>
                                    <textarea id="batchRenameRegex" class="form-control" rows="3"
                                        placeholder="例如: \s*V\d+\.?\d*| (去掉所有的 V1.2 等版本号)"></textarea>
                                </div>
                                <button type="button" id="applyBatchNamingBtn" class="btn btn-primary">
                                    <i class="fas fa-check"></i> 应用到所有节点
                                </button>
                            </div>
                            <div class="form-section">
                                <div class="form-section-title">
                                    <i class="fas fa-filter"></i>
                                    节点过滤规则
                                </div>
                                <div class="form-group">
                                    <label class="form-label">保留包含这些关键词的节点 (回车分隔)</label>
                                    <textarea id="keepKeywords" class="form-control" rows="3" placeholder="例如: 香港
美国"></textarea>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">剔除包含这些关键词的节点 (回车分隔)</label>
                                    <textarea id="dropKeywords" class="form-control" rows="3" placeholder="例如: 剩余流量
过期时间"></textarea>
                                </div>
                                <button type="button" id="applyBatchFilterBtn" class="btn btn-outline">
                                    <i class="fas fa-filter"></i> 执行过滤
                                </button>
                            </div>
                            <div class="form-section">
                                <div class="form-section-title">
                                    <i class="fas fa-tools"></i>
                                    高级处理
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                    <button type="button" id="removeDuplicatesBtn" class="btn btn-outline"
                                        style="width: 100%;">
                                        <i class="fas fa-copy"></i> 去除重复节点
                                    </button>
                                    <button type="button" id="sortByLatencyBtn" class="btn btn-outline"
                                        style="width: 100%;">
                                        <i class="fas fa-sort-amount-down"></i> 按延迟排序
                                    </button>
                                </div>
                            </div>
                            <div class="form-section">
                                <div class="form-section-title">
                                    <i class="fas fa-broom"></i>
                                    危险操作
                                </div>
                                <button type="button" id="clearAllNodesBtn" class="btn btn-outline"
                                    style="color: var(--danger); border-color: var(--danger);">
                                    <i class="fas fa-trash-alt"></i> 清空当前所有节点
                                </button>
                                <div class="form-help-text" style="margin-top: 10px;">
                                    此操作将从列表中移除所有已加载的节点，不可撤销。
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- TUN设置面板 -->
                    <div id="tun-panel" class="editor-panel">
                        <div class="editor-form">
                            <div class="form-section">
                                <div class="form-section-title">
                                    <i class="fas fa-ethernet"></i>
                                    TUN设置
                                </div>
                                <div class="checkbox-group">
                                    <input type="checkbox" id="tunEnable">
                                    <label for="tunEnable">启用TUN模式</label>
                                </div>
                                <div id="tunSettings" style="display: none; margin-top: 15px;">
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">设备名称</label>
                                            <input type="text" id="tunDevice" class="form-control" value="utun">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">协议栈</label>
                                            <select id="tunStack" class="form-select">
                                                <option value="mixed">Mixed</option>
                                                <option value="system">System</option>
                                                <option value="gvisor">gVisor</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label class="form-label">DNS劫持</label>
                                            <input type="text" id="tunDnsHijack" class="form-control" value="any:53">
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">MTU</label>
                                            <input type="number" id="tunMtu" class="form-control" value="9000">
                                        </div>
                                    </div>
                                    <div class="form-row">
                                        <div class="checkbox-group">
                                            <input type="checkbox" id="tunAutoRoute" checked>
                                            <label for="tunAutoRoute">自动路由</label>
                                        </div>
                                        <div class="checkbox-group">
                                            <input type="checkbox" id="tunAutoDetect" checked>
                                            <label for="tunAutoDetect">自动检测接口</label>
                                        </div>
                                        <div class="checkbox-group">
                                            <input type="checkbox" id="tunStrictRoute">
                                            <label for="tunStrictRoute">严格路由</label>
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">包含路由</label>
                                        <textarea id="tunIncludedRoutes" class="form-control" rows="3" placeholder="0.0.0.0/0
::/0"></textarea>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">排除路由</label>
                                        <textarea id="tunExcludedRoutes" class="form-control" rows="3" placeholder="10.0.0.0/8
172.16.0.0/12
192.168.0.0/16"></textarea>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 脚本设置面板 -->
                    <div id="script-panel" class="editor-panel">
                        <div class="editor-form">
                            <div class="form-section">
                                <div class="form-section-title">
                                    <i class="fas fa-code"></i>
                                    脚本设置
                                </div>
                                <div class="checkbox-group">
                                    <input type="checkbox" id="scriptEnable">
                                    <label for="scriptEnable">启用脚本支持</label>
                                </div>
                                <div id="scriptSettings" style="display: none; margin-top: 15px;">
                                    <div class="form-group">
                                        <label class="form-label">Profile URL</label>
                                        <input type="text" id="profileUrl" class="form-control"
                                            placeholder="https://example.com/profile.yaml">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">更新间隔</label>
                                        <input type="number" id="profileUpdateInterval" class="form-control" value="60"
                                            min="1">
                                        <small style="color: #6c757d; font-size: 12px;">分钟</small>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">预处理脚本</label>
                                        <textarea id="preprocessorScript" class="form-textarea" rows="5" placeholder="// JavaScript 预处理脚本
module.exports.parse = (raw, { yaml }) => {
    const parsed = yaml.parse(raw);
    // 修改配置
    return yaml.stringify(parsed);
};"></textarea>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">后处理脚本</label>
                                        <textarea id="postprocessorScript" class="form-textarea" rows="5" placeholder="// JavaScript 后处理脚本
module.exports.generate = (config, { yaml }) => {
    // 生成最终配置
    return yaml.stringify(config);
};"></textarea>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 可拖动分隔条 -->
            <div class="resize-handle" id="resizeHandle"></div>

            <!-- 右侧预览面板 -->
            <div class="preview-panel" id="previewPanel">
                <div class="preview-panel-header">
                    <div class="preview-panel-title">
                        <span class="preview-update-indicator"></span>
                        📋 实时预览
                    </div>
                    <!-- 多格式切换下拉菜单 (替换原有的 Tab 按钮) -->
                    <div style="margin: 8px 0;">
                        <select id="previewFormatSelect" class="form-select"
                            style="width: 100%; padding: 4px 8px; font-size: 12px; height: auto;">
                            <option value="clash-meta">Clash Meta</option>
                            <option value="sing-box">Sing-Box</option>
                            <option value="surge">Surge</option>
                            <option value="stash">Stash</option>
                            <option value="quantumultx">Quantumult X</option>
                            <option value="loon">Loon</option>
                            <option value="shadowrocket">Shadowrocket</option>
                            <option value="nekoray">Nekoray</option>
                            <option value="v2ray">V2Ray</option>
                            <option value="v2rayng">URI 链接</option>
                        </select>
                    </div>
                    <div class="preview-panel-stats">
                        <div class="preview-panel-stat">
                            <span>🌐</span>
                            <span id="previewNodeCount">0</span> 节点
                        </div>
                        <div class="preview-panel-stat">
                            <span>⚙️</span>
                            <span id="previewGroupCount">0</span> 策略组
                        </div>
                        <div class="preview-panel-stat">
                            <span>📜</span>
                            <span id="previewRuleCount">0</span> 规则
                        </div>
                    </div>
                </div>
                <div class="preview-panel-content">
                    <pre class="preview-panel-code" id="livePreviewCode"># 配置预览将在这里显示...</pre>
                </div>
                <div class="preview-panel-actions" style="display: flex; gap: 8px;">
                    <button id="copyPreviewBtn" class="btn btn-primary" style="flex: 1;">
                        <i class="fas fa-copy"></i> 复制配置
                    </button>
                    <button id="downloadPreviewBtn" class="btn btn-outline" style="flex: 1;">
                        <i class="fas fa-download"></i> 下载文件
                    </button>
                </div>
            </div>
        </div>



        <!-- 连通性测试模态框 -->
        <div id="connectivityModal"
            style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
            <div
                style="background: white; width: 500px; max-width: 90%; border-radius: 12px; padding: 25px; box-shadow: 0 4px 20px rgba(0,0,0,0.2);">
                <h3 style="margin-bottom: 20px; font-weight: 600; display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-satellite-dish" style="color: var(--primary);"></i> 连通性测试
                </h3>

                <div
                    style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border-radius: 6px; font-size: 13px; color: #856404; border: 1px solid #ffeeba;">
                    <i class="fas fa-exclamation-triangle"></i>
                    注意：此功能依赖本地 Clash 外部控制器。请确保 Clash 正在运行且已加载当前配置。
                </div>

                <div class="form-group">
                    <label class="form-label">测试目标 URL</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button class="btn btn-sm btn-outline"
                            onclick="document.getElementById('testTargetUrl').value='http://www.gstatic.com/generate_204'">Google</button>
                        <button class="btn btn-sm btn-outline"
                            onclick="document.getElementById('testTargetUrl').value='https://www.youtube.com'">YouTube</button>
                        <button class="btn btn-sm btn-outline"
                            onclick="document.getElementById('testTargetUrl').value='https://github.com'">GitHub</button>
                        <button class="btn btn-sm btn-outline"
                            onclick="document.getElementById('testTargetUrl').value='https://www.baidu.com'">Baidu</button>
                    </div>
                    <input type="text" id="testTargetUrl" class="form-control"
                        value="http://www.gstatic.com/generate_204" placeholder="输入测试网址...">
                </div>

                <div class="form-group">
                    <label class="form-label">API 地址 (External Controller)</label>
                    <input type="text" id="testApiUrl" class="form-control" value="http://127.0.0.1:9090">
                </div>

                <div class="form-group">
                    <label class="form-label">API Secret (如有)</label>
                    <input type="password" id="testApiSecret" class="form-control" placeholder="默认为空">
                </div>

                <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 25px;">
                    <button class="btn btn-outline"
                        onclick="document.getElementById('connectivityModal').style.display = 'none'">取消</button>
                    <button class="btn btn-primary" id="startConnectivityTestBtn">
                        <i class="fas fa-play"></i> 开始测试
                    </button>
                </div>
            </div>
        </div>

        <!-- 添加节点模态框 -->
        <div id="addNodeModal"
            style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
            <div style="background: white; width: 500px; max-width: 90%; border-radius: 12px; padding: 30px;">
                <h3 style="margin-bottom: 20px; font-weight: 600;">添加新节点</h3>
                <div style="display: flex; flex-direction: column; gap: 15px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">节点名称</label>
                        <input type="text" id="newNodeName" class="form-control" placeholder="输入节点名称">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">协议类型</label>
                        <select id="newNodeType" class="form-select">
                            <option value="vmess">VMess</option>
                            <option value="vless">VLESS</option>
                            <option value="trojan">Trojan</option>
                            <option value="ss">Shadowsocks</option>
                            <option value="ssr">ShadowsocksR</option>
                            <option value="hysteria">Hysteria</option>
                            <option value="hysteria2">Hysteria2</option>
                            <option value="tuic">TUIC</option>
                            <option value="snell">Snell</option>
                            <option value="wireguard">WireGuard</option>
                        </select>
                    </div>
                    <div style="display: flex; gap: 15px; margin-top: 20px;">
                        <button onclick="confirmAddNode()" class="btn btn-primary" style="flex: 1;">确认添加</button>
                        <button onclick="closeAddNodeModal()" class="btn btn-outline" style="flex: 1;">取消</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- 添加订阅源模态框 -->
        <div id="addSubModal"
            style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
            <div
                style="background: white; width: 550px; max-width: 95%; border-radius: 12px; padding: 30px; max-height: 90vh; overflow-y: auto;">
                <h3 style="margin-bottom: 20px; font-weight: 600; display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-rss-square" style="color: var(--primary);"></i> 添加订阅源
                </h3>
                <div style="display: flex; flex-direction: column; gap: 15px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">订阅名称 (若粘贴多行
                            URL，此名称将作为前缀)</label>
                        <input type="text" id="newSubName" class="form-control" placeholder="例如: 我的机场">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">订阅 URL (支持多行批量输入)</label>
                        <textarea id="newSubUrl" class="form-control" rows="4"
                            placeholder="每行一个链接 http:// 或 https://"></textarea>
                    </div>
                    <hr style="border: none; border-top: 1px solid var(--border); margin: 5px 0;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 500; font-size: 13px;">节点统称前缀
                                (可选)</label>
                            <input type="text" id="newSubPrefix" class="form-control" placeholder="例如: [机场A]">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 500; font-size: 13px;">包含关键词
                                (可选)</label>
                            <input type="text" id="newSubInclude" class="form-control" placeholder="仅同步包含这些词的节点">
                        </div>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 500; font-size: 13px;">排除关键词
                            (可选)</label>
                        <input type="text" id="newSubExclude" class="form-control" placeholder="不要同步包含这些词的节点">
                    </div>

                    <div style="display: flex; gap: 15px; margin-top: 10px;">
                        <button onclick="window.metaEditor.confirmAddSub()" class="btn btn-primary"
                            style="flex: 2;">确认添加</button>
                        <button onclick="document.getElementById('addSubModal').style.display='none'"
                            class="btn btn-outline" style="flex: 1;">取消</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- 协议解析器 -->
        <script>
            // ==================== 多客户端配置生成器 ====================

            // 基类 - 所有生成器继承此类
            class BaseGenerator {
                constructor(proxies, config) {
                    this.proxies = proxies || [];
                    this.config = config || {};
                }
                generate() { throw new Error('子类必须实现 generate()'); }
                getFormat() { return 'text'; }
                getFileExtension() { return '.txt'; }
                getMimeType() { return 'text/plain'; }

                // UTF-8 安全的 Base64 编码（支持中文等非 Latin1 字符）
                utf8ToBase64(str) {
                    try {
                        return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (_, p1) =>
                            String.fromCharCode(parseInt(p1, 16))
                        ));
                    } catch (e) {
                        // 回退方案
                        const bytes = new TextEncoder().encode(str);
                        let binary = '';
                        bytes.forEach(b => binary += String.fromCharCode(b));
                        return btoa(binary);
                    }
                }

                // URL 安全的 Base64 编码（用于 SSR 等）
                utf8ToBase64Url(str) {
                    return this.utf8ToBase64(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
                }
            }

            // ==================== Clash Meta 生成器 ====================
            class ClashMetaGenerator extends BaseGenerator {
                generate() {
                    // 复用现有 generateClashConfig 逻辑，返回 YAML
                    return window.metaEditor ? window.metaEditor.generateClashConfigYAML() : '';
                }
                getFormat() { return 'yaml'; }
                getFileExtension() { return '.yaml'; }
                getMimeType() { return 'text/yaml'; }
            }

            // ==================== Sing-Box 生成器 ====================
            class SingBoxGenerator extends BaseGenerator {
                generate(expandedIndex = -1) {
                    const config = {
                        log: { level: 'info', timestamp: true },
                        dns: {
                            servers: [
                                { tag: 'dns_proxy', address: 'https://1.1.1.1/dns-query', detour: 'proxy' },
                                { tag: 'dns_direct', address: '223.5.5.5', detour: 'direct' }
                            ],
                            rules: [
                                { outbound: 'any', server: 'dns_direct' }
                            ],
                            final: 'dns_proxy'
                        },
                        outbounds: [
                            { tag: 'proxy', type: 'selector', outbounds: this.proxies.map(p => p.name).concat(['direct']) },
                            { tag: 'direct', type: 'direct' },
                            { tag: 'block', type: 'block' },
                            ...this.proxies.map((p, idx) => this.generateOutbound(p, idx === expandedIndex))
                        ],
                        route: {
                            rules: [
                                { geosite: 'cn', outbound: 'direct' },
                                { geoip: 'cn', outbound: 'direct' },
                                { geoip: 'private', outbound: 'direct' }
                            ],
                            final: 'proxy'
                        }
                    };
                    // 对于正在编辑的节点，使用更大的缩进以便查看
                    return JSON.stringify(config, null, expandedIndex >= 0 ? 2 : 2);
                }

                generateOutbound(proxy, isExpanded = false) {
                    const base = { tag: proxy.name, server: proxy.server, server_port: proxy.port };

                    switch (proxy.type) {
                        case 'vless':
                            return {
                                ...base, type: 'vless', uuid: proxy.uuid, flow: proxy.flow || '',
                                tls: {
                                    enabled: proxy.tls || false, server_name: proxy.sni || proxy.servername || proxy.server,
                                    insecure: proxy['skip-cert-verify'] || false,
                                    utls: { enabled: true, fingerprint: proxy['client-fingerprint'] || 'chrome' },
                                    ech: proxy.ech ? {
                                        enabled: true,
                                        pq_signature_schemes_enabled: false,
                                        dynamic_configuration_enabled: false,
                                        config: proxy.echCode ? [proxy.echCode] : undefined
                                    } : undefined
                                },
                                ...this.getTransport(proxy)
                            };
                        case 'vmess':
                            return {
                                ...base, type: 'vmess', uuid: proxy.uuid, alter_id: proxy.alterId || 0,
                                security: proxy.cipher || 'auto',
                                tls: {
                                    enabled: proxy.tls || false, server_name: proxy.sni || proxy.server,
                                    insecure: proxy['skip-cert-verify'] || false,
                                    utls: { enabled: true, fingerprint: proxy['client-fingerprint'] || 'chrome' },
                                    ech: proxy.ech ? {
                                        enabled: true,
                                        config: proxy.echCode ? [proxy.echCode] : undefined
                                    } : undefined
                                },
                                ...this.getTransport(proxy)
                            };
                        case 'trojan':
                            return {
                                ...base, type: 'trojan', password: proxy.password,
                                tls: {
                                    enabled: true, server_name: proxy.sni || proxy.server,
                                    insecure: proxy['skip-cert-verify'] || false,
                                    utls: { enabled: true, fingerprint: proxy['client-fingerprint'] || 'chrome' },
                                    ech: proxy.ech ? {
                                        enabled: true,
                                        config: proxy.echCode ? [proxy.echCode] : undefined
                                    } : undefined
                                },
                                ...this.getTransport(proxy)
                            };
                        case 'ss':
                            return { ...base, type: 'shadowsocks', method: proxy.cipher, password: proxy.password };
                        case 'ssr':
                            return {
                                ...base, type: 'shadowsocksr', method: proxy.cipher, password: proxy.password,
                                protocol: proxy.protocol, protocol_param: proxy['protocol-param'] || '',
                                obfs: proxy.obfs, obfs_param: proxy['obfs-param'] || ''
                            };
                        case 'hysteria2':
                            return {
                                ...base, type: 'hysteria2', password: proxy.password,
                                tls: { enabled: true, server_name: proxy.sni || proxy.server }
                            };
                        default:
                            return { ...base, type: proxy.type };
                    }
                }

                getTransport(proxy) {
                    if (proxy.network === 'ws') {
                        return {
                            transport: {
                                type: 'ws', path: proxy['ws-opts']?.path || '/',
                                headers: proxy['ws-opts']?.headers || {}
                            }
                        };
                    }
                    if (proxy.network === 'grpc') {
                        return { transport: { type: 'grpc', service_name: proxy['grpc-opts']?.['grpc-service-name'] || '' } };
                    }
                    if (proxy.network === 'h2') {
                        return { transport: { type: 'http', path: proxy['h2-opts']?.path || '/' } };
                    }
                    return {};
                }

                getFormat() { return 'json'; }
                getFileExtension() { return '.json'; }
                getMimeType() { return 'application/json'; }
            }

            // ==================== Surge 生成器 ====================
            class SurgeGenerator extends BaseGenerator {
                generate(expandedIndex = -1) {
                    const lines = [];
                    lines.push('[General]');
                    lines.push('loglevel = notify');
                    lines.push('dns-server = 223.5.5.5, 119.29.29.29');
                    lines.push('skip-proxy = 127.0.0.1, 192.168.0.0/16, 10.0.0.0/8, 172.16.0.0/12, localhost, *.local');
                    lines.push('');

                    lines.push('[Proxy]');
                    this.proxies.forEach((p, idx) => {
                        const proxyLine = this.generateProxy(p);
                        lines.push(proxyLine);
                        // 如果是正在编辑的节点，添加详细注释
                        if (idx === expandedIndex) {
                            lines.push(`# → 正在编辑: ${p.name}`);
                            lines.push(`#    服务器: ${p.server}:${p.port}`);
                            lines.push(`#    类型: ${p.type.toUpperCase()}`);
                        }
                    });
                    lines.push('');

                    lines.push('[Proxy Group]');
                    lines.push(`Proxy = select, ${this.proxies.map(p => p.name).join(', ')}, DIRECT`);
                    lines.push('');

                    lines.push('[Rule]');
                    lines.push('GEOIP,CN,DIRECT');
                    lines.push('FINAL,Proxy');

                    return lines.join('\n');
                }

                generateProxy(proxy) {
                    switch (proxy.type) {
                        case 'ss':
                            return `${proxy.name} = ss, ${proxy.server}, ${proxy.port}, encrypt-method=${proxy.cipher}, password=${proxy.password}`;
                        case 'vmess':
                            return `${proxy.name} = vmess, ${proxy.server}, ${proxy.port}, username=${proxy.uuid}, tls=${proxy.tls || false}${proxy.ech ? ', tls-ech=true' : ''}`;
                        case 'trojan':
                            return `${proxy.name} = trojan, ${proxy.server}, ${proxy.port}, password=${proxy.password}, tls=true, sni=${proxy.sni || proxy.server}${proxy.ech ? ', tls-ech=true' : ''}`;
                        case 'vless':
                            return `${proxy.name} = vless, ${proxy.server}, ${proxy.port}, username=${proxy.uuid}, tls=${proxy.tls || false}${proxy.ech ? ', tls-ech=true' : ''}`;
                        default:
                            return `# ${proxy.name} - 不支持的类型: ${proxy.type}`;
                    }
                }

                getFormat() { return 'conf'; }
                getFileExtension() { return '.conf'; }
                getMimeType() { return 'text/plain'; }
            }

            // ==================== V2RayNG 生成器 ====================
            class V2RayNGGenerator extends BaseGenerator {
                generate(expandedIndex = -1) {
                    const lines = [];
                    this.proxies.forEach((p, idx) => {
                        const uri = this.generateUri(p);
                        if (uri) {
                            lines.push(uri);
                            // 如果是正在编辑的节点，添加详细注释
                            if (idx === expandedIndex) {
                                lines.push(`# → 正在编辑: ${p.name}`);
                                lines.push(`#    服务器: ${p.server}:${p.port}`);
                                lines.push(`#    类型: ${p.type.toUpperCase()}`);
                                lines.push('');
                            }
                        }
                    });
                    return lines.join('\n');
                }

                generateUri(proxy) {
                    switch (proxy.type) {
                        case 'vmess': return this.buildVmessUri(proxy);
                        case 'vless': return this.buildVlessUri(proxy);
                        case 'trojan': return this.buildTrojanUri(proxy);
                        case 'ss': return this.buildSSUri(proxy);
                        default: return '';
                    }
                }

                buildVmessUri(p) {
                    const config = {
                        v: '2', ps: p.name, add: p.server, port: p.port, id: p.uuid, aid: p.alterId || 0,
                        scy: p.cipher || 'auto', net: p.network || 'tcp', type: p.obfsType || 'none', tls: p.tls ? 'tls' : ''
                    };
                    if (p.tls && (p.sni || p.servername)) {
                        config.sni = p.sni || p.servername;
                    }

                    // 处理 WebSocket 传输层
                    if (p.network === 'ws') {
                        const ws = p['ws-opts'] || {};
                        config.path = ws.path || '/';
                        config.host = ws.headers?.Host || '';
                    }
                    // 处理 TCP HTTP 伪装
                    else if (p.obfsType === 'http' || (p.network === 'tcp' && p['http-opts'])) {
                        config.type = 'http';
                        const http = p['http-opts'] || {};
                        config.path = Array.isArray(http.path) ? http.path[0] : (http.path || '/');
                        config.host = (http.headers?.Host && Array.isArray(http.headers.Host)) ? http.headers.Host[0] : (http.headers?.Host || '');
                    }

                    return 'vmess://' + this.utf8ToBase64(JSON.stringify(config));
                }

                buildVlessUri(p) {
                    // 直接使用 MetaProtocolParser 的统一逻辑
                    return new MetaProtocolParser().buildVlessLink(p);
                }

                buildTrojanUri(p) {
                    const params = new URLSearchParams();
                    params.set('type', p.network || 'tcp');
                    params.set('security', 'tls');
                    if (p.sni) params.set('sni', p.sni);
                    if (p['ws-opts']?.path) params.set('path', p['ws-opts'].path);
                    return `trojan://${p.password}@${p.server}:${p.port}?${params.toString()}#${encodeURIComponent(p.name)}`;
                }

                buildSSUri(p) {
                    const userinfo = this.utf8ToBase64(`${p.cipher}:${p.password}`);
                    return `ss://${userinfo}@${p.server}:${p.port}#${encodeURIComponent(p.name)}`;
                }

                getFormat() { return 'uri'; }
                getFileExtension() { return '.txt'; }
                getMimeType() { return 'text/plain'; }
            }

            // ==================== Shadowrocket 生成器 ====================
            class ShadowrocketGenerator extends BaseGenerator {
                generate(expandedIndex = -1) {
                    const lines = [];
                    this.proxies.forEach((p, idx) => {
                        const uri = this.generateUri(p);
                        if (uri) {
                            lines.push(uri);
                            // 如果是正在编辑的节点，添加详细注释
                            if (idx === expandedIndex) {
                                lines.push(`# → 正在编辑: ${p.name}`);
                                lines.push(`#    服务器: ${p.server}:${p.port}`);
                                lines.push(`#    类型: ${p.type.toUpperCase()}`);
                                lines.push('');
                            }
                        }
                    });
                    return lines.join('\n');
                }

                generateUri(proxy) {
                    switch (proxy.type) {
                        case 'vmess': return this.buildVmessUri(proxy);
                        case 'vless': return this.buildVlessUri(proxy);
                        case 'trojan': return this.buildTrojanUri(proxy);
                        case 'ss': return this.buildSSUri(proxy);
                        case 'ssr': return this.buildSSRUri(proxy);
                        case 'hysteria2': return this.buildHysteria2Uri(proxy);
                        case 'hysteria': return this.buildHysteriaUri(proxy);
                        default: return '';
                    }
                }

                buildVmessUri(p) {
                    const config = {
                        v: '2', ps: p.name, add: p.server, port: p.port, id: p.uuid, aid: p.alterId || 0,
                        scy: p.cipher || 'auto', net: p.network || 'tcp', type: p.obfsType || 'none', tls: p.tls ? 'tls' : ''
                    };
                    if (p.tls && (p.sni || p.servername)) {
                        config.sni = p.sni || p.servername;
                    }

                    if (p.network === 'ws') {
                        const ws = p['ws-opts'] || {};
                        config.path = ws.path || '/';
                        config.host = ws.headers?.Host || '';
                    } else if (p.obfsType === 'http' || (p.network === 'tcp' && p['http-opts'])) {
                        config.type = 'http';
                        const http = p['http-opts'] || {};
                        config.path = Array.isArray(http.path) ? http.path[0] : (http.path || '/');
                        config.host = (http.headers?.Host && Array.isArray(http.headers.Host)) ? http.headers.Host[0] : (http.headers?.Host || '');
                    }
                    return 'vmess://' + this.utf8ToBase64(JSON.stringify(config));
                }

                buildVlessUri(p) {
                    return new MetaProtocolParser().buildVlessLink(p);
                }

                buildTrojanUri(p) {
                    const params = new URLSearchParams();
                    params.set('type', p.network || 'tcp');
                    params.set('security', 'tls');
                    if (p.sni) params.set('sni', p.sni);
                    if (p['ws-opts']?.path) params.set('path', p['ws-opts'].path);
                    return `trojan://${p.password}@${p.server}:${p.port}?${params.toString()}#${encodeURIComponent(p.name)}`;
                }

                buildSSUri(p) {
                    const userinfo = this.utf8ToBase64(`${p.cipher}:${p.password}`);
                    return `ss://${userinfo}@${p.server}:${p.port}#${encodeURIComponent(p.name)}`;
                }

                // SSR 链接生成
                buildSSRUri(p) {
                    // SSR 格式: ssr://base64(server:port:protocol:method:obfs:password_base64/?params)
                    const password_b64 = this.utf8ToBase64Url(p.password || '');
                    const obfsparam_b64 = this.utf8ToBase64Url(p['obfs-param'] || '');
                    const protoparam_b64 = this.utf8ToBase64Url(p['protocol-param'] || '');
                    const remarks_b64 = this.utf8ToBase64Url(p.name || '');

                    const main = `${p.server}:${p.port}:${p.protocol || 'origin'}:${p.cipher}:${p.obfs || 'plain'}:${password_b64}`;
                    const params = `obfsparam=${obfsparam_b64}&protoparam=${protoparam_b64}&remarks=${remarks_b64}`;

                    const full = `${main}/?${params}`;
                    return 'ssr://' + this.utf8ToBase64Url(full);
                }

                buildHysteria2Uri(p) {
                    const params = new URLSearchParams();
                    if (p.sni) params.set('sni', p.sni);
                    if (p['skip-cert-verify']) params.set('insecure', '1');
                    return `hysteria2://${p.password}@${p.server}:${p.port}?${params.toString()}#${encodeURIComponent(p.name)}`;
                }

                buildHysteriaUri(p) {
                    const params = new URLSearchParams();
                    if (p.sni) params.set('peer', p.sni);
                    if (p.up) params.set('upmbps', p.up);
                    if (p.down) params.set('downmbps', p.down);
                    if (p['auth-str']) params.set('auth', p['auth-str']);
                    return `hysteria://${p.server}:${p.port}?${params.toString()}#${encodeURIComponent(p.name)}`;
                }

                getFormat() { return 'uri'; }
                getFileExtension() { return '.txt'; }
                getMimeType() { return 'text/plain'; }
            }

            // ==================== Stash 生成器 ====================
            class StashGenerator extends ClashMetaGenerator {
                // Stash 兼容 Clash Meta 格式
                getFileExtension() { return '.yaml'; }
            }

            // ==================== Quantumult X 生成器 ====================
            class QuantumultXGenerator extends BaseGenerator {
                generate(expandedIndex = -1) {
                    const lines = ['# Quantumult X 配置', `# 生成时间: ${new Date().toISOString()}`, ''];
                    lines.push('[server_local]');
                    this.proxies.forEach((p, idx) => {
                        const line = this.generateServer(p);
                        if (line) {
                            lines.push(line);
                            // 如果是正在编辑的节点，添加详细注释
                            if (idx === expandedIndex) {
                                lines.push(`# → 正在编辑: ${p.name}`);
                                lines.push(`#    服务器: ${p.server}:${p.port}`);
                                lines.push(`#    类型: ${p.type.toUpperCase()}`);
                            }
                        }
                    });
                    lines.push('');
                    lines.push('[filter_local]');
                    lines.push('geoip, cn, direct');
                    lines.push('final, proxy');
                    return lines.join('\n');
                }

                generateServer(p) {
                    switch (p.type) {
                        case 'vmess':
                            return `vmess=${p.server}:${p.port}, method=${p.cipher || 'auto'}, password=${p.uuid}, tag=${p.name}${p.ech ? ', tls-ech=true' : ''}`;
                        case 'vless':
                            return `vless=${p.server}:${p.port}, password=${p.uuid}, tag=${p.name}${p.ech ? ', tls-ech=true' : ''}`;
                        case 'trojan':
                            return `trojan=${p.server}:${p.port}, password=${p.password}, over-tls=true, tls-verification=${p['skip-cert-verify'] ? 'false' : 'true'}, tag=${p.name}${p.ech ? ', tls-ech=true' : ''}`;
                        case 'ss':
                            return `shadowsocks=${p.server}:${p.port}, method=${p.cipher}, password=${p.password}, tag=${p.name}`;
                        default:
                            return `# ${p.name} - 不支持`;
                    }
                }

                getFormat() { return 'conf'; }
                getFileExtension() { return '.conf'; }
                getMimeType() { return 'text/plain'; }
            }

            // ==================== Loon 生成器 ====================
            class LoonGenerator extends BaseGenerator {
                generate(expandedIndex = -1) {
                    const lines = ['#!MANAGED-CONFIG', `# 生成时间: ${new Date().toISOString()}`, ''];
                    lines.push('[Proxy]');
                    this.proxies.forEach((p, idx) => {
                        const line = this.generateProxy(p);
                        if (line) {
                            lines.push(line);
                            // 如果是正在编辑的节点，添加详细注释
                            if (idx === expandedIndex) {
                                lines.push(`# → 正在编辑: ${p.name}`);
                                lines.push(`#    服务器: ${p.server}:${p.port}`);
                                lines.push(`#    类型: ${p.type.toUpperCase()}`);
                            }
                        }
                    });
                    lines.push('');
                    lines.push('[Rule]');
                    lines.push('GEOIP,CN,DIRECT');
                    lines.push('FINAL,PROXY');
                    return lines.join('\n');
                }

                generateProxy(p) {
                    switch (p.type) {
                        case 'vmess':
                            return `${p.name} = vmess, ${p.server}, ${p.port}, ${p.uuid}, transport=${p.network || 'tcp'}${p.ech ? ', ech=true' : ''}`;
                        case 'vless':
                            return `${p.name} = vless, ${p.server}, ${p.port}, ${p.uuid}${p.ech ? ', ech=true' : ''}`;
                        case 'trojan':
                            return `${p.name} = trojan, ${p.server}, ${p.port}, ${p.password}${p.ech ? ', ech=true' : ''}`;
                        case 'ss':
                            return `${p.name} = Shadowsocks, ${p.server}, ${p.port}, ${p.cipher}, "${p.password}"`;
                        default:
                            return `# ${p.name} - 不支持`;
                    }
                }

                getFormat() { return 'conf'; }
                getFileExtension() { return '.conf'; }
                getMimeType() { return 'text/plain'; }
            }

            // ==================== Nekoray 生成器 ====================
            class NekorayGenerator extends BaseGenerator {
                generate() {
                    const profile = {
                        outbounds: this.proxies.map(p => this.generateOutbound(p)).filter(o => o)
                    };
                    return JSON.stringify(profile, null, 2);
                }

                generateOutbound(p) {
                    const base = { tag: p.name, address: p.server, port: p.port };
                    switch (p.type) {
                        case 'vless':
                            return { ...base, protocol: 'vless', settings: { vnext: [{ address: p.server, port: p.port, users: [{ id: p.uuid, flow: p.flow || '' }] }] } };
                        case 'vmess':
                            return { ...base, protocol: 'vmess', settings: { vnext: [{ address: p.server, port: p.port, users: [{ id: p.uuid, alterId: p.alterId || 0 }] }] } };
                        case 'trojan':
                            return { ...base, protocol: 'trojan', settings: { servers: [{ address: p.server, port: p.port, password: p.password }] } };
                        default:
                            return null;
                    }
                }

                getFormat() { return 'json'; }
                getFileExtension() { return '.json'; }
                getMimeType() { return 'application/json'; }
            }

            // ==================== V2Ray 生成器 ====================
            class V2RayGenerator extends BaseGenerator {
                generate() {
                    const config = {
                        log: { loglevel: 'warning' },
                        inbounds: [
                            { port: 1080, listen: '127.0.0.1', protocol: 'socks', settings: { auth: 'noauth' } },
                            { port: 1081, listen: '127.0.0.1', protocol: 'http' }
                        ],
                        outbounds: this.proxies.map(p => this.generateOutbound(p)).filter(o => o),
                        routing: { rules: [{ type: 'field', ip: ['geoip:cn', 'geoip:private'], outboundTag: 'direct' }] }
                    };
                    config.outbounds.unshift({ protocol: 'freedom', tag: 'direct' });
                    return JSON.stringify(config, null, 2);
                }

                generateOutbound(p) {
                    switch (p.type) {
                        case 'vless':
                            return {
                                protocol: 'vless', tag: p.name, settings: { vnext: [{ address: p.server, port: p.port, users: [{ id: p.uuid, flow: p.flow || '', encryption: 'none' }] }] },
                                streamSettings: this.getStreamSettings(p)
                            };
                        case 'vmess':
                            return {
                                protocol: 'vmess', tag: p.name, settings: { vnext: [{ address: p.server, port: p.port, users: [{ id: p.uuid, alterId: p.alterId || 0 }] }] },
                                streamSettings: this.getStreamSettings(p)
                            };
                        case 'trojan':
                            return {
                                protocol: 'trojan', tag: p.name, settings: { servers: [{ address: p.server, port: p.port, password: p.password }] },
                                streamSettings: this.getStreamSettings(p)
                            };
                        case 'ss':
                            return {
                                protocol: 'shadowsocks', tag: p.name, settings: { servers: [{ address: p.server, port: p.port, method: p.cipher, password: p.password }] }
                            };
                        default:
                            return null;
                    }
                }

                getStreamSettings(p) {
                    const ss = { network: p.network || 'tcp' };
                    const serverName = p.sni || p.servername || p.server;
                    const fingerprint = p.fingerprint || p['client-fingerprint'] || (p.ech ? 'chrome' : '');

                    if (p.reality) {
                        ss.security = 'reality';
                        ss.realitySettings = {
                            serverName: serverName,
                            fingerprint: fingerprint || 'chrome',
                            publicKey: p['reality-opts']?.['public-key'] || '',
                            shortId: p['reality-opts']?.['short-id'] || '',
                            spiderX: ""
                        };
                    } else if (p.tls || p.ech) {
                        ss.security = 'tls';
                        ss.tlsSettings = {
                            serverName: serverName,
                            allowInsecure: p['skip-cert-verify'] || false,
                            fingerprint: fingerprint,
                            alpn: p.alpn || []
                        };
                        if (p.ech && p.echCode) {
                            ss.tlsSettings.ech = {
                                enabled: true,
                                config: [p.echCode]
                            };
                        }
                    }

                    if (p.network === 'ws') {
                        ss.wsSettings = {
                            path: p['ws-opts']?.path || '/',
                            headers: p['ws-opts']?.headers || {}
                        };
                    } else if (p.network === 'grpc') {
                        ss.grpcSettings = {
                            serviceName: p['grpc-opts']?.['grpc-service-name'] || '',
                            multiMode: true
                        };
                    } else if (p.network === 'h2' || p.network === 'http') {
                        ss.httpSettings = {
                            path: p['h2-opts']?.path || '/',
                            host: p['h2-opts']?.host ? (Array.isArray(p['h2-opts'].host) ? p['h2-opts'].host : [p['h2-opts'].host]) : [serverName]
                        };
                        // v2ray/xray 使用 http 作为 h2 的传输协议名
                        ss.network = 'http';
                    }
                    return ss;
                }

                getFormat() { return 'json'; }
                getFileExtension() { return '.json'; }
                getMimeType() { return 'application/json'; }
            }

            // ==================== 生成器工厂 ====================
            class ClientGeneratorFactory {
                static generators = {
                    'clash-meta': ClashMetaGenerator,
                    'sing-box': SingBoxGenerator,
                    'surge': SurgeGenerator,
                    'v2rayng': V2RayNGGenerator,
                    'shadowrocket': ShadowrocketGenerator,
                    'stash': StashGenerator,
                    'quantumultx': QuantumultXGenerator,
                    'loon': LoonGenerator,
                    'nekoray': NekorayGenerator,
                    'v2ray': V2RayGenerator
                };

                static create(clientType, proxies, config) {
                    const Generator = this.generators[clientType];
                    if (!Generator) throw new Error(`不支持的客户端: ${clientType}`);
                    return new Generator(proxies, config);
                }

                static getSupportedClients() {
                    return Object.keys(this.generators);
                }
            }
        </script>

        <script>
            class MetaProtocolParser {
                constructor() {
                    console.log('Meta 协议解析器初始化');
                }

                // Base64 解码 (支持 UTF-8)
                base64Decode(str) {
                    try {
                        if (!str) return '';
                        str = str.replace(/-/g, '+').replace(/_/g, '/').replace(/\s/g, '');
                        while (str.length % 4) str += '=';
                        const binary = atob(str);
                        const bytes = new Uint8Array(binary.length);
                        for (let i = 0; i < binary.length; i++) {
                            bytes[i] = binary.charCodeAt(i);
                        }
                        return new TextDecoder('utf-8').decode(bytes);
                    } catch (e) {
                        try {
                            // 次要尝试：处理某些特殊的编码情况
                            return decodeURIComponent(escape(atob(str)));
                        } catch (e2) {
                            console.warn('Base64 decode failed:', e);
                            return str;
                        }
                    }
                }

                base64Encode(str) {
                    return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => {
                        return String.fromCharCode('0x' + p1);
                    }));
                }

                parseAnyLink(link) {
                    link = link.trim();
                    if (!link) throw new Error('链接为空');

                    if (link.startsWith('vmess://')) {
                        return this.parseVmess(link);
                    } else if (link.startsWith('vless://')) {
                        return this.parseVless(link);
                    } else if (link.startsWith('trojan://')) {
                        return this.parseTrojan(link);
                    } else if (link.startsWith('ss://')) {
                        return this.parseSS(link);
                    } else if (link.startsWith('ssr://')) {
                        return this.parseSSR(link);
                    } else if (link.startsWith('hysteria://')) {
                        return this.parseHysteria(link);
                    } else if (link.startsWith('hy2://') || link.startsWith('hysteria2://')) {
                        return this.parseHysteria2(link);
                    } else if (link.startsWith('tuic://')) {
                        return this.parseTuic(link);
                    } else if (link.startsWith('snell://')) {
                        return this.parseSnell(link);
                    } else if (link.startsWith('wg://') || link.startsWith('wireguard://')) {
                        return this.parseWireGuard(link);
                    } else if (link.startsWith('socks://') || link.startsWith('socks5://')) {
                        return this.parseSocksHttp(link);
                    } else if (link.startsWith('http://') || link.startsWith('https://')) {
                        // 如果包含 @，通常是带认证的 http/socks 代理，否则可能是订阅链接
                        if (link.includes('@')) {
                            return this.parseSocksHttp(link);
                        } else {
                            throw new Error('SUBSCRIPTION_URL'); // 特殊标识，由 Editor 处理 fetch
                        }
                    } else {
                        throw new Error('不支持的协议格式: ' + link.substring(0, 20) + '...');
                    }
                }

                unindent(text) {
                    const lines = text.split('\n');
                    // 找到最小有效缩进（忽略空行）
                    let minIndent = Infinity;
                    lines.forEach(line => {
                        const trimmed = line.trim();
                        if (trimmed.length > 0) {
                            const indent = line.match(/^\s*/)[0].length;
                            if (indent < minIndent) minIndent = indent;
                        }
                    });
                    if (minIndent === Infinity || minIndent === 0) return text;
                    return lines.map(line => line.length >= minIndent ? line.substring(minIndent) : line.trim()).join('\n');
                }

                // 解析订阅内容（支持 Clash YAML, Base64, JSON 和普通列表）
                parseSubscription(content) {
                    // 清洗不可见字符和多余空格，同时清理可能误入的中文标点符（常见于手机端复制）
                    content = content.replace(/[\u200B-\u200D\uFEFF]/g, '');
                    content = content.replace(/，/g, ',').replace(/：/g, ':').replace(/“|”|‘|’/g, '"').trim();

                    if (!content) return { proxies: [], errors: [] };
                    let allProxies = [];

                    // 2. 尝试 Base64 解码
                    const looksLikeBase64 = /^[A-Za-z0-9+/= \t\n\r]+$/.test(content);
                    if (looksLikeBase64 && !content.includes('name:') && !content.includes('server:') && !content.includes('{')) {
                        try {
                            const decoded = this.base64Decode(content);
                            if (decoded && (decoded.includes('://') || decoded.toLowerCase().includes('proxies:') || decoded.includes('name:'))) {
                                return this.parseSubscription(decoded);
                            }
                        } catch (e) { }
                    }

                    // 2.5 尝试解析为 JSON
                    const jsonBlocks = this.extractAllJSONObjects(content);
                    let handledAsJSON = false;
                    if (jsonBlocks.length > 0) {
                        jsonBlocks.forEach(block => {
                            try {
                                const data = JSON.parse(block);
                                let res = this.parseV2rayJSON(data);
                                if (res.length === 0) res = this.parseRawProxyJSON(data);
                                if (res.length > 0) {
                                    allProxies = allProxies.concat(res);
                                    // 如果整个内容就是一个 JSON 对象，标记已处理，防止后续识别为其他格式
                                    if (block.trim() === content.trim()) {
                                        handledAsJSON = true;
                                    }
                                }
                            } catch (e) { }
                        });
                    }

                    if (handledAsJSON) {
                        return { proxies: allProxies, errors: [] };
                    }

                    // 1. 尝试解析为 Clash YAML
                    const looksLikeYAML = content.toLowerCase().includes('name:') || content.toLowerCase().includes('proxies:') || content.includes('- ');

                    if (looksLikeYAML) {
                        const extractProxies = (data) => {
                            if (!data) return [];
                            if (data.proxies && Array.isArray(data.proxies)) return data.proxies;
                            if (Array.isArray(data)) return data.filter(i => i && typeof i === 'object' && (i.name || i.server));
                            if (typeof data === 'object' && data.name && data.type) return [data];
                            return [];
                        };

                        const tryParseAny = (text) => {
                            if (!text) return [];
                            try {
                                // 优先尝试全文本直接 load
                                const doc = jsyaml.load(text);
                                const found = extractProxies(doc);
                                if (found && found.length > 0) return found;
                            } catch (e) { }

                            //备选方案：正则提取 (当 YAML 解析失败或不完整时)
                            const regexExtractNode = (t) => {
                                const getVal = (k) => {
                                    const m = t.match(new RegExp(`${k}\\s*:\\s*['"]?([^'"\\n\\r,]+)['"]?`, 'i'));
                                    return m ? m[1].trim() : null;
                                };
                                const n = getVal('name'), s = getVal('server'), ty = getVal('type');
                                if (n && s) return [{ name: n, type: ty || 'ss', server: s, port: parseInt(getVal('port')) || 443, password: getVal('password') || getVal('uuid') || '', cipher: getVal('cipher') || 'auto', udp: true }];
                                return [];
                            };

                            try {
                                // 尝试 loadAll
                                const docs = [];
                                jsyaml.loadAll(text, (doc) => {
                                    const found = extractProxies(doc);
                                    if (found) docs.push(...found);
                                });
                                if (docs.length > 0) return docs;
                            } catch (e) { }
                            return [];
                        };

                        // 拾荒者解析逻辑：整体 -> 反缩进 -> 包裹 -> 物理分割
                        let found = tryParseAny(content.replace(/^\s*[Pp]?roxies\s*:/im, 'proxies:'));

                        if (found.length === 0) {
                            const clean = this.unindent(content);
                            found = tryParseAny(clean);
                            if (found.length === 0) {
                                found = tryParseAny("proxies:\n" + (clean.startsWith('- ') ? clean : "  " + clean));
                            }
                        }

                        // 物理切割逻辑：无论整体解析是否成功，都尝试物理分割以防漏网之鱼
                        const markerRegex = /^[ \t]*-?[ \t]*name\s*:/gm;
                        let m, markers = [];
                        while ((m = markerRegex.exec(content)) !== null) markers.push(m.index);

                        if (markers.length > 0) {
                            for (let i = 0; i < markers.length; i++) {
                                let block = content.substring(markers[i], markers[i + 1] || content.length).trim();
                                if (!block) continue;
                                let res = tryParseAny(block);
                                if (res.length === 0) res = tryParseAny(this.unindent(block));
                                if (res.length === 0) res = tryParseAny("proxies:\n" + (block.startsWith('- ') ? block : "  " + block));

                                // 终极策略：如果该块通过上述方案都失败了，强制正则提取核心参数
                                if (res.length === 0) {
                                    const getVal = (k) => {
                                        const m = block.match(new RegExp(`${k}\\s*:\\s*['"]?([^'"\\n\\r,]+)['"]?`, 'i'));
                                        return m ? m[1].trim() : null;
                                    };
                                    const n = getVal('name'), s = getVal('server'), ty = getVal('type') || 'ss';
                                    if (n && s) {
                                        const node = {
                                            name: n,
                                            server: s,
                                            type: ty,
                                            port: parseInt(getVal('port')) || 443,
                                            password: getVal('password') || getVal('uuid') || '',
                                            cipher: getVal('cipher') || 'auto',
                                            udp: true
                                        };
                                        if (ty === 'ssr') {
                                            node.protocol = getVal('protocol') || 'origin';
                                            node.obfs = getVal('obfs') || 'plain';
                                            node['protocol-param'] = getVal('protocol-param') || '';
                                            node['obfs-param'] = getVal('obfs-param') || '';
                                        }
                                        res = [node];
                                    }
                                }
                                found = found.concat(res);
                            }
                        }

                        if (found.length > 0) {
                            allProxies = allProxies.concat(found);
                        }
                    }

                    // 3. 尝试作为普通链接列表提取
                    const linkProxies = this.parseLinks(content).proxies;
                    if (linkProxies.length > 0) {
                        allProxies = allProxies.concat(linkProxies);
                    }

                    // 4. 去重
                    const seen = new Set();
                    const uniqueProxies = allProxies.filter(p => {
                        if (!p || (!p.name && !p.server)) return false;
                        const key = `${p.type}:${p.server}:${p.port}:${p.name}`;
                        if (seen.has(key)) return false;
                        seen.add(key);
                        return true;
                    });

                    return { proxies: uniqueProxies, errors: [] };
                }


                // 从文本中扫描并提取所有 JSON 对象 {}，支持嵌套
                extractAllJSONObjects(text) {
                    const results = [];
                    let braceCount = 0;
                    let start = -1;
                    let inString = false;
                    let escape = false;

                    for (let i = 0; i < text.length; i++) {
                        const char = text[i];
                        if (escape) {
                            escape = false;
                            continue;
                        }
                        if (char === '\\') {
                            escape = true;
                            continue;
                        }
                        if (char === '"') {
                            inString = !inString;
                            continue;
                        }
                        if (inString) continue;

                        if (char === '{') {
                            if (braceCount === 0) start = i;
                            braceCount++;
                        } else if (char === '}') {
                            braceCount--;
                            if (braceCount === 0 && start !== -1) {
                                results.push(text.substring(start, i + 1));
                                start = -1;
                            }
                        }
                    }
                    return results;
                }

                // 解析 v2rayN JSON 格式
                parseV2rayJSON(data) {
                    const results = [];
                    const processObject = (obj) => {
                        // 过滤掉非代理协议
                        const skipProtocols = ['freedom', 'blackhole', 'dns', 'api'];
                        if (skipProtocols.includes(obj.protocol)) return;

                        // v2rayN 节点的典型特征
                        if (obj.tag && obj.protocol && obj.settings) {
                            try {
                                const proxy = {
                                    name: obj.tag,
                                    type: obj.protocol,
                                    server: '',
                                    port: 443,
                                    udp: true
                                };

                                // 特殊处理协议名转换
                                if (proxy.type === 'shadowsocks') proxy.type = 'ss';

                                // 解析服务器与核心信息
                                if (obj.settings.vnext && obj.settings.vnext[0]) {
                                    const vnext = obj.settings.vnext[0];
                                    proxy.server = vnext.address;
                                    proxy.port = vnext.port;
                                    if (vnext.users && vnext.users[0]) {
                                        proxy.uuid = vnext.users[0].id;
                                        if (obj.protocol === 'vmess') {
                                            proxy.alterId = vnext.users[0].alterId || 0;
                                            proxy.cipher = vnext.users[0].security || 'auto';
                                        }
                                    }
                                } else if (obj.settings.servers && obj.settings.servers[0]) {
                                    const srv = obj.settings.servers[0];
                                    proxy.server = srv.address;
                                    proxy.port = srv.port;
                                    if (obj.protocol === 'trojan') proxy.password = srv.password;
                                    if (obj.protocol === 'ss' || obj.protocol === 'shadowsocks') {
                                        proxy.cipher = srv.method;
                                        proxy.password = srv.password;
                                    }
                                }

                                // 解析传输层设置 (streamSettings)
                                if (obj.streamSettings) {
                                    const ss = obj.streamSettings;
                                    proxy.network = ss.network || 'tcp';
                                    if (ss.security === 'tls') {
                                        proxy.tls = true;
                                        const tls = ss.tlsSettings || {};
                                        proxy.servername = tls.serverName;
                                        proxy['skip-cert-verify'] = tls.allowInsecure === true;
                                    } else if (ss.security === 'reality') {
                                        proxy.tls = true;
                                        proxy.reality = true;
                                        const reality = ss.realitySettings || {};
                                        proxy.servername = reality.serverName;
                                        if (!proxy['reality-opts']) proxy['reality-opts'] = {};
                                        proxy['reality-opts']['public-key'] = reality.publicKey;
                                        proxy['reality-opts']['short-id'] = reality.shortId;
                                        proxy.fingerprint = reality.fingerprint || 'chrome';
                                    }

                                    if (ss.wsSettings) {
                                        proxy['ws-opts'] = {
                                            path: ss.wsSettings.path || '/',
                                            headers: ss.wsSettings.headers || {}
                                        };
                                    } else if (ss.grpcSettings) {
                                        proxy['grpc-opts'] = {
                                            'grpc-service-name': ss.grpcSettings.serviceName || 'GunService'
                                        };
                                    }
                                }

                                if (proxy.server) results.push(proxy);
                            } catch (e) {
                                console.warn('解析单个 v2ray 节点失败', e);
                            }
                        }
                    };

                    if (Array.isArray(data)) {
                        data.forEach(processObject);
                    } else if (data && typeof data === 'object') {
                        // 支持完整的 v2ray 配置文件结构
                        if (Array.isArray(data.outbounds)) {
                            data.outbounds.forEach(processObject);
                        } else {
                            processObject(data);
                        }
                    }
                    return results;
                }

                // 解析原始 SS/SSR JSON 格式 (例如 shadowsocks-libev 配置文件)
                parseRawProxyJSON(data) {
                    const results = [];
                    const processObject = (obj) => {
                        if (obj.server && (obj.server_port || obj.port) && (obj.password || obj.key)) {
                            try {
                                const proxy = {
                                    name: obj.name || obj.remarks || 'JSON节点',
                                    server: obj.server,
                                    port: parseInt(obj.server_port || obj.port),
                                    password: obj.password || obj.key,
                                    cipher: obj.method || obj.cipher || 'aes-256-gcm',
                                    udp: true
                                };

                                // 判断是 SSR 还是普通 SS
                                if (obj.protocol || obj.obfs) {
                                    proxy.type = 'ssr';
                                    proxy.protocol = obj.protocol || 'origin';
                                    proxy.obfs = obj.obfs || 'plain';
                                    if (obj.protocol_param || obj['protocol-param']) {
                                        proxy['protocol-param'] = obj.protocol_param || obj['protocol-param'];
                                    }
                                    if (obj.obfs_param || obj['obfs-param']) {
                                        proxy['obfs-param'] = obj.obfs_param || obj['obfs-param'];
                                    }
                                } else {
                                    proxy.type = 'ss';
                                    // SS 特有的插件处理
                                    if (obj.plugin) {
                                        proxy.plugin = obj.plugin;
                                        proxy['plugin-opts'] = obj.plugin_opts || {};
                                    }
                                }
                                results.push(proxy);
                            } catch (e) { }
                        }
                    };

                    if (Array.isArray(data)) {
                        data.forEach(processObject);
                    } else if (data && typeof data === 'object') {
                        processObject(data);
                    }
                    return results;
                }

                parseVmess(link) {
                    try {
                        let content = link.substring(8);
                        let name = 'VMess节点';

                        if (content.includes('#')) {
                            const parts = content.split('#');
                            content = parts[0];
                            name = decodeURIComponent(parts[1]);
                        }

                        const decoded = this.base64Decode(content);
                        const config = JSON.parse(decoded);

                        const result = {
                            name: config.ps || name,
                            type: 'vmess',
                            server: config.add || '',
                            port: config.port, // 保持原始格式（字符串或数字）
                            uuid: config.id || '',
                            alterId: parseInt(config.aid) || 0,
                            cipher: config.scy || 'auto',
                            tls: config.tls === 'tls',
                            network: config.net || 'tcp',
                            udp: true
                        };

                        // 处理传输层参数
                        if (result.network === 'ws') {
                            result['ws-opts'] = {
                                path: config.path || '/',
                                headers: { Host: config.host || '' }
                            };
                        } else if (result.network === 'grpc') {
                            result['grpc-opts'] = {
                                'grpc-service-name': config.path || ''
                            };
                        } else if (result.network === 'tcp' && config.type === 'http') {
                            result.obfsType = 'http';
                            result['http-opts'] = {
                                path: [config.path || '/'],
                                headers: { Host: [config.host || ''] }
                            };
                        }

                        // TLS 相关：仅在开启 TLS 时设置 SNI
                        if (result.tls) {
                            result.servername = config.sni || config.host || '';
                            result['skip-cert-verify'] = config.allowInsecure === true || config.allowInsecure === '1';
                        }

                        // 处理 Reality
                        if (config.realityOpts) {
                            result.reality = true;
                            result.tls = true;
                            result['reality-opts'] = {
                                'public-key': config.realityOpts.publicKey || config.realityOpts['public-key'],
                                'short-id': config.realityOpts.shortId || config.realityOpts['short-id']
                            };
                        }

                        // 处理指纹
                        if (config.fp) {
                            result.fingerprint = config.fp;
                        }

                        // 处理 ALPN
                        if (config.alpn) {
                            result.alpn = Array.isArray(config.alpn) ? config.alpn : [config.alpn];
                        }

                        return result;
                    } catch (e) {
                        throw new Error('VMess解析失败: ' + e.message);
                    }
                }

                parseVless(link) {
                    try {
                        // 使用临时替换协议的方法来增强 URL 解析的鲁棒性
                        const url = new URL(link.replace(/^vless:\/\//i, 'https://'));
                        const uuid = url.username;
                        const server = url.hostname;
                        const port = parseInt(url.port) || 443;
                        const name = decodeURIComponent(url.hash.substring(1)) || 'VLESS节点';

                        const result = {
                            name: name,
                            type: 'vless',
                            server: server,
                            port: port,
                            uuid: uuid,
                            cipher: 'none',
                            udp: true,
                            'skip-cert-verify': false
                        };

                        url.searchParams.forEach((value, key) => {
                            const lowerKey = key.toLowerCase();
                            if (lowerKey === 'security') {
                                result.tls = value === 'tls' || value === 'reality';
                                if (value === 'reality') result.reality = true;
                            } else if (lowerKey === 'type') {
                                result.network = value;
                            } else if (lowerKey === 'path') {
                                result.wsPath = decodeURIComponent(value);
                            } else if (lowerKey === 'host') {
                                result.wsHost = decodeURIComponent(value);
                            } else if (lowerKey === 'sni') {
                                result.servername = decodeURIComponent(value);
                            } else if (lowerKey === 'flow') {
                                result.flow = decodeURIComponent(value);
                            } else if (lowerKey === 'pbk') {
                                if (!result['reality-opts']) result['reality-opts'] = {};
                                result['reality-opts']['public-key'] = decodeURIComponent(value);
                            } else if (lowerKey === 'sid') {
                                if (!result['reality-opts']) result['reality-opts'] = {};
                                result['reality-opts']['short-id'] = decodeURIComponent(value);
                            } else if (lowerKey === 'fp') {
                                result.fingerprint = decodeURIComponent(value);
                            } else if (lowerKey === 'alpn') {
                                result.alpn = decodeURIComponent(value).split(',');
                            } else if (lowerKey === 'allowinsecure') {
                                result['skip-cert-verify'] = value === '1' || value === 'true';
                            } else if (lowerKey === 'servicename') {
                                result.grpcServiceName = decodeURIComponent(value);
                            } else if (lowerKey === 'ech') {
                                // 存储 ECH 原始字符串，例如 'cloudflare-ech.com+https://cn.aliyun.com/dns-query'
                                // 或者解码后的值，具体取决于 Meta 核心要求。由于链接中是 URL 编码的，这里解一下。
                                result.echCode = decodeURIComponent(value);
                                result.ech = true;
                            } else if (lowerKey === 'insecure') {
                                result.insecure = value === '1' || value === 'true';
                            }
                        });

                        if ((result.wsPath || result.wsHost) && !result.network) result.network = 'ws';
                        if (result.network === 'ws' && (result.wsPath || result.wsHost)) {
                            result['ws-opts'] = { path: result.wsPath || '/', headers: {} };
                            if (result.wsHost) result['ws-opts'].headers.Host = result.wsHost;
                            delete result.wsPath; delete result.wsHost;
                        }

                        return result;
                    } catch (e) {
                        throw new Error('VLESS解析失败: ' + e.message);
                    }
                }

                parseTrojan(link) {
                    try {
                        const url = new URL(link.replace(/^trojan:\/\//i, 'https://'));
                        const password = url.username;
                        const server = url.hostname;
                        const port = parseInt(url.port) || 443;
                        const name = decodeURIComponent(url.hash.substring(1)) || 'Trojan节点';

                        const result = {
                            name: name,
                            type: 'trojan',
                            server: server,
                            port: port,
                            password: password,
                            tls: true,
                            udp: true
                        };

                        url.searchParams.forEach((value, key) => {
                            if (key === 'sni' || key === 'peer') {
                                result.sni = decodeURIComponent(value);
                            } else if (key === 'allowInsecure') {
                                result['skip-cert-verify'] = value === '1';
                            } else if (key === 'alpn') {
                                result.alpn = decodeURIComponent(value).split(',');
                            } else if (key === 'fp') {
                                result.fingerprint = decodeURIComponent(value);
                            } else if (key === 'type') {
                                result.network = decodeURIComponent(value);
                            } else if (key === 'path') {
                                result.wsPath = decodeURIComponent(value);
                            } else if (key === 'host') {
                                result.wsHost = decodeURIComponent(value);
                            }
                        });

                        return result;
                    } catch (e) {
                        throw new Error('Trojan解析失败: ' + e.message);
                    }
                }

                parseSS(link) {
                    try {
                        let content = link.substring(5);
                        let name = 'Shadowsocks节点';

                        if (content.includes('#')) {
                            const parts = content.split('#');
                            content = parts[0];
                            name = decodeURIComponent(parts[1]);
                        }

                        // 检查是否是 SIP002 格式
                        if (content.includes('@')) {
                            // SIP002 格式: method:password@server:port
                            const atIndex = content.indexOf('@');
                            const methodPass = content.substring(0, atIndex);
                            const serverPort = content.substring(atIndex + 1);

                            const colonIndex = methodPass.indexOf(':');
                            const method = decodeURIComponent(methodPass.substring(0, colonIndex));
                            const password = decodeURIComponent(methodPass.substring(colonIndex + 1));

                            const colonIndex2 = serverPort.lastIndexOf(':');
                            const server = serverPort.substring(0, colonIndex2);
                            const port = parseInt(serverPort.substring(colonIndex2 + 1));

                            return {
                                name: name,
                                type: 'ss',
                                server: server,
                                port: port,
                                cipher: method,
                                password: password,
                                udp: true
                            };
                        } else {
                            // 传统 base64 格式
                            const decoded = this.base64Decode(content);
                            const atIndex = decoded.indexOf('@');
                            if (atIndex === -1) throw new Error('SS链接格式错误');

                            const methodPass = decoded.substring(0, atIndex);
                            const serverPort = decoded.substring(atIndex + 1);

                            const colonIndex = methodPass.indexOf(':');
                            const method = methodPass.substring(0, colonIndex);
                            const password = methodPass.substring(colonIndex + 1);

                            const colonIndex2 = serverPort.lastIndexOf(':');
                            const server = serverPort.substring(0, colonIndex2);
                            const port = parseInt(serverPort.substring(colonIndex2 + 1));

                            return {
                                name: name,
                                type: 'ss',
                                server: server,
                                port: port,
                                cipher: method,
                                password: password,
                                udp: true
                            };
                        }
                    } catch (e) {
                        throw new Error('SS解析失败: ' + e.message);
                    }
                }

                parseSSR(link) {
                    try {
                        let content = link.substring(6);
                        const decoded = this.base64Decode(content);

                        // SSR格式: server:port:protocol:method:obfs:password_base64/?params
                        const parts = decoded.split('/?');
                        const mainParts = parts[0].split(':');

                        if (mainParts.length < 6) throw new Error('SSR链接格式错误');

                        // 从后往前提取固定字段，以兼容包含冒号的 IPv6 地址
                        // 顺序：password <- obfs <- method <- protocol <- port <- server
                        const password = this.base64Decode(mainParts.pop());
                        const obfs = mainParts.pop();
                        const method = mainParts.pop();
                        const protocol = mainParts.pop();
                        const port = parseInt(mainParts.pop());
                        const server = mainParts.join(':'); // 剩余部分即为服务器地址

                        let name = 'SSR节点';
                        let obfsparam = '';
                        let protoparam = '';

                        if (parts.length > 1) {
                            const params = new URLSearchParams(parts[1]);

                            // 修复部分旧版 SSR 链接参数可能包含的分号包裹问题
                            let rawObfs = params.get('obfsparam') || '';
                            if (rawObfs.length > 1 && rawObfs.startsWith(';') && rawObfs.endsWith(';')) {
                                rawObfs = rawObfs.slice(1, -1);
                            }
                            obfsparam = this.base64Decode(rawObfs);
                            // 进一步清理解码后可能存在的包裹字符
                            obfsparam = obfsparam.replace(/^["';]+|["';]+$/g, '');

                            let rawProto = params.get('protoparam') || '';
                            if (rawProto.length > 1 && rawProto.startsWith(';') && rawProto.endsWith(';')) {
                                rawProto = rawProto.slice(1, -1);
                            }
                            protoparam = this.base64Decode(rawProto);
                            // 进一步清理解码后可能存在的包裹字符
                            protoparam = protoparam.replace(/^["';]+|["';]+$/g, '');

                            const remarks = params.get('remarks');
                            if (remarks) {
                                name = this.base64Decode(remarks);
                            }
                        }

                        return {
                            name: name,
                            type: 'ssr',
                            server: server,
                            port: port,
                            cipher: method,
                            password: password,
                            protocol: protocol,
                            'protocol-param': protoparam,
                            obfs: obfs,
                            'obfs-param': obfsparam,
                            udp: true
                        };
                    } catch (e) {
                        throw new Error('SSR解析失败: ' + e.message);
                    }
                }

                parseHysteria(link) {
                    try {
                        const url = new URL(link);
                        const server = url.hostname;
                        const port = parseInt(url.port) || 443;
                        const name = decodeURIComponent(url.hash.substring(1)) || 'Hysteria节点';

                        const result = {
                            name: name,
                            type: 'hysteria',
                            server: server,
                            port: port,
                            version: '1',
                            udp: true
                        };

                        url.searchParams.forEach((value, key) => {
                            if (key === 'auth') {
                                result.auth = decodeURIComponent(value);
                            } else if (key === 'peer') {
                                result.sni = decodeURIComponent(value);
                            } else if (key === 'insecure') {
                                result['skip-cert-verify'] = value === '1';
                            } else if (key === 'alpn') {
                                result.alpn = decodeURIComponent(value).split(',');
                            } else if (key === 'obfs') {
                                result.obfs = decodeURIComponent(value);
                            } else if (key === 'obfsParam') {
                                result['obfs-param'] = decodeURIComponent(value);
                            } else if (key === 'upmbps') {
                                result.up = value + ' Mbps';
                            } else if (key === 'downmbps') {
                                result.down = value + ' Mbps';
                            }
                        });

                        return result;
                    } catch (e) {
                        throw new Error('Hysteria解析失败: ' + e.message);
                    }
                }

                parseHysteria2(link) {
                    try {
                        const url = new URL(link);
                        const server = url.hostname;
                        const port = parseInt(url.port) || 443;
                        const name = decodeURIComponent(url.hash.substring(1)) || 'Hysteria2节点';

                        const result = {
                            name: name,
                            type: 'hysteria2',
                            server: server,
                            port: port,
                            version: '2',
                            udp: true
                        };

                        url.searchParams.forEach((value, key) => {
                            if (key === 'auth' || key === 'password') {
                                result.password = decodeURIComponent(value);
                            } else if (key === 'sni') {
                                result.sni = decodeURIComponent(value);
                            } else if (key === 'insecure') {
                                result['skip-cert-verify'] = value === '1';
                            } else if (key === 'alpn') {
                                result.alpn = decodeURIComponent(value).split(',');
                            } else if (key === 'obfs') {
                                result.obfs = decodeURIComponent(value);
                            } else if (key === 'obfs-password') {
                                result['obfs-password'] = decodeURIComponent(value);
                            }
                        });

                        return result;
                    } catch (e) {
                        throw new Error('Hysteria2解析失败: ' + e.message);
                    }
                }

                parseTuic(link) {
                    try {
                        const url = new URL(link);
                        const server = url.hostname;
                        const port = parseInt(url.port) || 443;
                        const name = decodeURIComponent(url.hash.substring(1)) || 'TUIC节点';

                        const result = {
                            name: name,
                            type: 'tuic',
                            server: server,
                            port: port,
                            version: '5',
                            udp: true
                        };

                        url.searchParams.forEach((value, key) => {
                            if (key === 'uuid') {
                                result.uuid = decodeURIComponent(value);
                            } else if (key === 'password') {
                                result.password = decodeURIComponent(value);
                            } else if (key === 'sni') {
                                result.sni = decodeURIComponent(value);
                            } else if (key === 'alpn') {
                                result.alpn = decodeURIComponent(value).split(',');
                            } else if (key === 'allowInsecure') {
                                result['skip-cert-verify'] = value === '1';
                            } else if (key === 'disable_sni') {
                                result['disable-sni'] = value === '1';
                            }
                        });

                        return result;
                    } catch (e) {
                        throw new Error('TUIC解析失败: ' + e.message);
                    }
                }

                parseSnell(link) {
                    try {
                        const url = new URL(link);
                        const server = url.hostname;
                        const port = parseInt(url.port) || 443;
                        const name = decodeURIComponent(url.hash.substring(1)) || 'Snell节点';

                        const result = {
                            name: name,
                            type: 'snell',
                            server: server,
                            port: port,
                            version: '2',
                            udp: true
                        };

                        url.searchParams.forEach((value, key) => {
                            if (key === 'psk') {
                                result.psk = decodeURIComponent(value);
                            } else if (key === 'obfs') {
                                result.obfs = decodeURIComponent(value);
                            } else if (key === 'obfs-host') {
                                result['obfs-host'] = decodeURIComponent(value);
                            } else if (key === 'version') {
                                result.version = decodeURIComponent(value);
                            }
                        });

                        return result;
                    } catch (e) {
                        throw new Error('Snell解析失败: ' + e.message);
                    }
                }

                parseWireGuard(link) {
                    try {
                        const url = new URL(link);
                        const server = url.hostname;
                        const port = parseInt(url.port) || 51820;
                        const name = decodeURIComponent(url.hash.substring(1)) || 'WireGuard节点';

                        const result = {
                            name: name,
                            type: 'wireguard',
                            server: server,
                            port: port,
                            udp: true
                        };

                        url.searchParams.forEach((value, key) => {
                            if (key === 'private_key') {
                                result['private-key'] = decodeURIComponent(value);
                            } else if (key === 'public_key') {
                                result['public-key'] = decodeURIComponent(value);
                            } else if (key === 'preshared_key') {
                                result['preshared-key'] = decodeURIComponent(value);
                            } else if (key === 'local_address' || key === 'address') {
                                result['local-address'] = decodeURIComponent(value).split(',');
                            } else if (key === 'dns') {
                                result.dns = decodeURIComponent(value).split(',');
                            } else if (key === 'mtu') {
                                result.mtu = parseInt(decodeURIComponent(value));
                            } else if (key === 'reserved') {
                                result.reserved = decodeURIComponent(value).split(',').map(Number);
                            }
                        });

                        return result;
                    } catch (e) {
                        throw new Error('WireGuard解析失败: ' + e.message);
                    }
                }

                parseSocksHttp(link) {
                    try {
                        // 处理协议头
                        const protocol = link.split('://')[0].toLowerCase();
                        let content = link.substring(protocol.length + 3);
                        let query = '';
                        let fragment = '';

                        // 提取查询参数和片段
                        if (content.includes('#')) {
                            const parts = content.split('#');
                            content = parts[0];
                            fragment = parts[1];
                        }
                        if (content.includes('?')) {
                            const parts = content.split('?');
                            content = parts[0];
                            query = parts[1];
                        }

                        // 尝试判断 content 是否为 Base64
                        // SOCKS 链接常见的 Base64 格式解码后通常包含 @ 或 :
                        if (!content.includes('@') && !content.includes(':')) {
                            try {
                                const decoded = this.base64Decode(content);
                                if (decoded.includes('@') || (decoded.includes(':') && !isNaN(parseInt(decoded.split(':').pop())))) {
                                    content = decoded;
                                }
                            } catch (e) {
                                // 解码失败说明不是 Base64，保持原样
                            }
                        }

                        // 构造一个标准的 URL 以利用 URL API 进行解析
                        // 如果已经包含协议名且符合格式，则直接解析，否则拼装
                        let urlToParse = content.includes('://') ? content : `${protocol}://${content}`;
                        if (query) urlToParse += `?${query}`;
                        if (fragment) urlToParse += `#${fragment}`;

                        const url = new URL(urlToParse);
                        const server = url.hostname;
                        const port = parseInt(url.port) || (protocol.includes('https') ? 443 : 80);

                        // 默认名称
                        let name = decodeURIComponent(url.hash.substring(1)) ||
                            (protocol.includes('socks') ? 'SOCKS5节点' : 'HTTP节点');

                        const result = {
                            name: name,
                            type: protocol.includes('socks') ? 'socks5' : 'http',
                            server: server,
                            port: port,
                            udp: true // SOCKS 节点默认开启 UDP
                        };

                        if (url.username) {
                            result.username = decodeURIComponent(url.username);
                        }
                        if (url.password) {
                            result.password = decodeURIComponent(url.password);
                        }

                        // 解析查询参数
                        const searchParams = new URLSearchParams(query);
                        searchParams.forEach((value, key) => {
                            const lowKey = key.toLowerCase();
                            if (lowKey === 'remarks' || lowKey === 'ps' || lowKey === 'name') {
                                result.name = decodeURIComponent(value);
                            } else if (lowKey === 'udp') {
                                result.udp = value === 'true' || value === '1';
                            } else if (lowKey === 'tls') {
                                result.tls = value === 'true';
                            } else if (lowKey === 'skip-cert-verify') {
                                result['skip-cert-verify'] = value === 'true';
                            } else if (lowKey === 'sni') {
                                result.sni = decodeURIComponent(value);
                            }
                        });

                        return result;
                    } catch (e) {
                        throw new Error('SOCKS/HTTP解析失败: ' + e.message);
                    }
                }

                parseLinks(text) {
                    const lines = text.split('\n')
                        .map(line => line.trim())
                        .filter(line => line && !line.startsWith('#'));

                    const proxies = [];
                    const errors = [];

                    lines.forEach((line, index) => {
                        try {
                            const proxy = this.parseAnyLink(line);
                            proxies.push(proxy);
                        } catch (e) {
                            errors.push(`第${index + 1}行: ${e.message}`);
                        }
                    });

                    return { proxies, errors };
                }

                // 新增：将节点对象转换为协议链接
                toLink(proxy) {
                    try {
                        switch (proxy.type) {
                            case 'vmess': return this.buildVmessLink(proxy);
                            case 'vless': return this.buildVlessLink(proxy);
                            case 'ss': return this.buildSSLink(proxy);
                            case 'ssr': return this.buildSSRLink(proxy);
                            case 'trojan': return this.buildTrojanLink(proxy);
                            case 'hysteria':
                            case 'hysteria2': return this.buildHysteriaLink(proxy);
                            case 'tuic': return this.buildTuicLink(proxy);
                            case 'snell': return this.buildSnellLink(proxy);
                            default: return `不支持转换该协议 (${proxy.type})`;
                        }
                    } catch (e) {
                        return `转换失败: ${e.message}`;
                    }
                }

                buildVmessLink(p) {
                    const obj = {
                        v: "2",
                        ps: p.name,
                        add: p.server,
                        port: p.port,
                        id: p.uuid,
                        aid: p.alterId || "0",
                        scy: p.cipher || "auto",
                        net: p.network || "tcp",
                        type: "none",
                        host: p.wsHost || p['ws-opts']?.headers?.Host || "",
                        path: p.wsPath || p['ws-opts']?.path || "",
                        tls: p.tls ? "tls" : "",
                        sni: p.servername || p.sni || "",
                        alpn: Array.isArray(p.alpn) ? p.alpn.join(',') : (p.alpn || "")
                    };
                    return 'vmess://' + this.base64Encode(JSON.stringify(obj, null, 2));
                }

                buildVlessLink(p) {
                    const params = new URLSearchParams();
                    params.set('encryption', p.cipher || 'none');

                    // 基础 TLS/Reality 安全设置
                    const security = p.reality ? 'reality' : (p.tls || p.ech ? 'tls' : 'none');
                    params.set('security', security);

                    if (p.flow) params.set('flow', p.flow);
                    if (p.network) params.set('type', p.network);

                    const host = p.wsHost || p['ws-opts']?.headers?.Host || (p['h2-opts']?.host ? (Array.isArray(p['h2-opts'].host) ? p['h2-opts'].host[0] : p['h2-opts'].host) : '');
                    if (host) params.set('host', host);

                    const path = p.wsPath || p['ws-opts']?.path || p['h2-opts']?.path || p['grpc-opts']?.['grpc-service-name'];
                    if (path) params.set('path', path);

                    const sni = p.servername || p.sni || p.server;
                    if (sni && security !== 'none') params.set('sni', sni);

                    const fp = p.fingerprint || p['client-fingerprint'] || (p.ech ? 'chrome' : '');
                    if (fp) params.set('fp', fp);

                    // ALPN
                    if (p.alpn) params.set('alpn', Array.isArray(p.alpn) ? p.alpn.join(',') : p.alpn);

                    // Insecure
                    params.set('insecure', p.insecure ? '1' : '0');
                    params.set('allowInsecure', (p['skip-cert-verify'] || p.insecure) ? '1' : '0');

                    if (p.reality && p['reality-opts']) {
                        const r = p['reality-opts'];
                        if (r['public-key']) params.set('pbk', r['public-key']);
                        if (r['short-id']) params.set('sid', r['short-id']);
                    }

                    // ECH 设置
                    if (p.ech && p.echCode) {
                        params.set('ech', p.echCode);
                    }

                    return `vless://${p.uuid}@${p.server}:${p.port}?${params.toString()}#${encodeURIComponent(p.name)}`;
                }

                buildSSLink(p) {
                    // SIP002 标准: BASE64(method:password) (no padding)
                    const auth = this.base64Encode(`${p.cipher}:${p.password}`).replace(/=/g, '');
                    return `ss://${auth}@${p.server}:${p.port}#${encodeURIComponent(p.name)}`;
                }

                buildSSRLink(p) {
                    // SSR 链接需要去除所有 Base64 填充符以提高第三方库兼容性
                    const passB64 = this.base64Encode(p.password).replace(/=/g, '');
                    const remarksB64 = this.base64Encode(p.name).replace(/=/g, '');
                    const protoParamB64 = p['protocol-param'] ? this.base64Encode(p['protocol-param']).replace(/=/g, '') : '';
                    const obfsParamB64 = p['obfs-param'] ? this.base64Encode(p['obfs-param']).replace(/=/g, '') : '';

                    const main = `${p.server}:${p.port}:${p.protocol || 'origin'}:${p.cipher || 'aes-256-cfb'}:${p.obfs || 'plain'}:${passB64}`;
                    const query = `obfsparam=${obfsParamB64}&protoparam=${protoParamB64}&remarks=${remarksB64}`;

                    return `ssr://` + this.base64Encode(`${main}/?${query}`).replace(/=/g, '');
                }

                buildTrojanLink(p) {
                    const params = new URLSearchParams();
                    const sni = p.sni || p.servername;
                    if (sni) params.set('sni', sni);
                    if (p['skip-cert-verify']) params.set('allowInsecure', '1');
                    if (p.network) params.set('type', p.network);
                    if (p.alpn) params.set('alpn', Array.isArray(p.alpn) ? p.alpn.join(',') : p.alpn);

                    let query = params.toString();
                    return `trojan://${p.password}@${p.server}:${p.port}${query ? '?' + query : ''}#${encodeURIComponent(p.name)}`;
                }

                buildHysteriaLink(p) {
                    const protocol = p.type === 'hysteria2' ? 'hysteria2' : 'hysteria';
                    const params = new URLSearchParams();
                    const auth = p.password || p.auth;
                    if (auth) params.set(p.type === 'hysteria2' ? 'password' : 'auth', auth);
                    if (p.sni || p.servername) params.set('sni', p.sni || p.servername);
                    if (p['skip-cert-verify']) params.set('insecure', '1');
                    if (p.obfs) params.set('obfs', p.obfs);

                    let query = params.toString();
                    return `${protocol}://${p.server}:${p.port}${query ? '?' + query : ''}#${encodeURIComponent(p.name)}`;
                }

                buildTuicLink(p) {
                    const params = new URLSearchParams();
                    params.set('version', p.version || 5);
                    if (p.password) params.set('password', p.password);
                    if (p.sni || p.servername) params.set('sni', p.sni || p.servername);
                    if (p['skip-cert-verify']) params.set('allowInsecure', '1');
                    if (p.alpn) params.set('alpn', Array.isArray(p.alpn) ? p.alpn.join(',') : p.alpn);

                    return `tuic://${p.uuid}@${p.server}:${p.port}?${params.toString()}#${encodeURIComponent(p.name)}`;
                }

                buildSnellLink(p) {
                    return `snell://${p.server}:${p.port}?psk=${encodeURIComponent(p.psk || '')}&version=${p.version || 2}#${encodeURIComponent(p.name)}`;
                }
            }
        </script>

        <!-- 主应用逻辑 -->
        <script>
            class ClashMetaEditor {
                constructor() {
                    window.metaEditor = this;
                    this.parser = new MetaProtocolParser();
                    this.proxies = [];
                    this.currentNode = null;
                    this.defaultProxyGroups = [
                        { name: 'proxy', type: 'select', proxies: ['DIRECT', '香港', '台湾', '日本', '新加坡', '美国', '其它地区', '全部节点', '自动选择'] },
                        { name: 'dns', type: 'select', proxies: ['DIRECT', '自动选择', 'proxy', '香港', '台湾', '日本', '新加坡', '美国', '其它地区', '全部节点'] },
                        { name: 'AI服务', type: 'select', proxies: ['美国', '日本', '新加坡', '香港', '台湾', 'proxy', '自动选择'] },
                        { name: '游戏加速', type: 'select', proxies: ['DIRECT', '香港', '日本', '台湾', '自动选择', 'proxy'] },
                        { name: '微软服务', type: 'select', proxies: ['DIRECT', '自动选择', 'proxy', '香港', '美国', '日本'] },
                        { name: '苹果服务', type: 'select', proxies: ['DIRECT', '香港', '台湾', '美国', 'proxy', '自动选择'] },
                        { name: '开发者', type: 'select', proxies: ['自动选择', 'proxy', '香港', '美国', '日本', 'DIRECT'] },
                        { name: 'Google', anchor: 'pr' },
                        { name: 'Telegram', anchor: 'pr' },
                        { name: 'Twitter', anchor: 'pr' },
                        { name: 'Pixiv', anchor: 'pr' },
                        { name: 'ehentai', anchor: 'pr' },
                        { name: '哔哩哔哩', anchor: 'pr' },
                        { name: '哔哩东南亚', anchor: 'pr' },
                        { name: '巴哈姆特', anchor: 'pr' },
                        { name: 'YouTube', anchor: 'pr' },
                        { name: 'NETFLIX', anchor: 'pr' },
                        { name: 'Spotify', anchor: 'pr' },
                        { name: 'Github', anchor: 'pr' },
                        { name: '国内', type: 'select', proxies: ['DIRECT', 'proxy', '香港', '台湾', '日本', '新加坡', '美国', '其它地区', '全部节点', '自动选择'] },
                        { name: 'others', anchor: 'pr' },
                        { name: '香港', anchor: 'use', filter: "(?i)港|hk|hongkong|hong kong" },
                        { name: '台湾', anchor: 'use', filter: "(?i)台|tw|taiwan" },
                        { name: '日本', anchor: 'use', filter: "(?i)日本|jp|japan" },
                        { name: '美国', anchor: 'use', filter: "(?i)美|us|unitedstates|united states" },
                        { name: '新加坡', anchor: 'use', filter: "(?i)(新|sg|singapore)" },
                        { name: '其它地区', anchor: 'use', filter: "(?i)^(?!.*(?:🇭🇰|🇯🇵|🇺🇸|🇸🇬|🇨🇳|港|hk|hongkong|台|tw|taiwan|日|jp|japan|新|sg|singapore|美|us|unitedstates)).*" },
                        { name: '全部节点', anchor: 'use' },
                        { name: '自动选择', anchor: 'use', type: 'url-test', tolerance: 50, interval: 300, url: 'http://www.gstatic.com/generate_204' }
                    ];

                    this.config = {
                        subscriptions: [],
                        port: 7890,
                        'mixed-port': 7890,
                        'allow-lan': true,
                        mode: 'rule',
                        'log-level': 'info',
                        ipv6: true,
                        'external-controller': '127.0.0.1:9090',
                        'unified-delay': false,
                        'tcp-concurrent': true,
                        'geodata-mode': true,
                        'geox-url': {
                            geoip: "https://fastly.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geoip.dat",
                            geosite: "https://fastly.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geosite.dat",
                            mmdb: "https://fastly.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/country.mmdb"
                        },
                        'find-process-mode': 'strict',
                        'global-client-fingerprint': 'chrome',
                        profile: {
                            'store-selected': true,
                            'store-fake-ip': true
                        },
                        sniffer: {
                            enable: true,
                            sniff: {
                                TLS: { ports: [443, 8443] },
                                HTTP: { ports: [80, '8080-8880'], 'override-destination': true }
                            }
                        },
                        'proxy-providers': {
                            'provider1': { url: "" },
                            'provider2': { url: "" }
                        },
                        proxies: [],
                        'proxy-groups': [
                            { name: 'proxy', type: 'select', proxies: ['DIRECT', '香港', '台湾', '日本', '新加坡', '美国', '其它地区', '全部节点', '自动选择'] },
                            { name: 'dns', type: 'select', proxies: ['DIRECT', '自动选择', 'proxy', '香港', '台湾', '日本', '新加坡', '美国', '其它地区', '全部节点'] },
                            { name: 'AI服务', type: 'select', proxies: ['美国', '日本', '新加坡', '香港', '台湾', 'proxy', '自动选择'] },
                            { name: '游戏加速', type: 'select', proxies: ['DIRECT', '香港', '日本', '台湾', '自动选择', 'proxy'] },
                            { name: '微软服务', type: 'select', proxies: ['DIRECT', '自动选择', 'proxy', '香港', '美国', '日本'] },
                            { name: '苹果服务', type: 'select', proxies: ['DIRECT', '香港', '台湾', '美国', 'proxy', '自动选择'] },
                            { name: '开发者', type: 'select', proxies: ['自动选择', 'proxy', '香港', '美国', '日本', 'DIRECT'] },
                            { name: 'Google', anchor: 'pr' },
                            { name: 'Telegram', anchor: 'pr' },
                            { name: 'Twitter', anchor: 'pr' },
                            { name: 'Pixiv', anchor: 'pr' },
                            { name: 'ehentai', anchor: 'pr' },
                            { name: '哔哩哔哩', anchor: 'pr' },
                            { name: '哔哩东南亚', anchor: 'pr' },
                            { name: '巴哈姆特', anchor: 'pr' },
                            { name: 'YouTube', anchor: 'pr' },
                            { name: 'NETFLIX', anchor: 'pr' },
                            { name: 'Spotify', anchor: 'pr' },
                            { name: 'Github', anchor: 'pr' },
                            { name: '国内', type: 'select', proxies: ['DIRECT', 'proxy', '香港', '台湾', '日本', '新加坡', '美国', '其它地区', '全部节点', '自动选择'] },
                            { name: 'others', anchor: 'pr' },
                            { name: '香港', anchor: 'use', filter: "(?i)港|hk|hongkong|hong kong" },
                            { name: '台湾', anchor: 'use', filter: "(?i)台|tw|taiwan" },
                            { name: '日本', anchor: 'use', filter: "(?i)日本|jp|japan" },
                            { name: '美国', anchor: 'use', filter: "(?i)美|us|unitedstates|united states" },
                            { name: '新加坡', anchor: 'use', filter: "(?i)(新|sg|singapore)" },
                            { name: '其它地区', anchor: 'use', filter: "(?i)^(?!.*(?:🇭🇰|🇯🇵|🇺🇸|🇸🇬|🇨🇳|港|hk|hongkong|台|tw|taiwan|日|jp|japan|新|sg|singapore|美|us|unitedstates)).*" },
                            { name: '全部节点', anchor: 'use' },
                            { name: '自动选择', anchor: 'use', type: 'url-test', tolerance: 50, interval: 300, url: 'http://www.gstatic.com/generate_204' }
                        ],
                        rules: [
                            // AI 服务
                            'GEOSITE,openai,AI服务',
                            'DOMAIN-SUFFIX,openai.com,AI服务',
                            'DOMAIN-SUFFIX,chatgpt.com,AI服务',
                            'DOMAIN-SUFFIX,oaistatic.com,AI服务',
                            'DOMAIN-SUFFIX,oaiusercontent.com,AI服务',
                            'DOMAIN-SUFFIX,anthropic.com,AI服务',
                            'DOMAIN-SUFFIX,claude.ai,AI服务',
                            'DOMAIN-SUFFIX,gemini.google.com,AI服务',
                            'DOMAIN-SUFFIX,bard.google.com,AI服务',
                            'DOMAIN-SUFFIX,deepmind.com,AI服务',
                            'DOMAIN-SUFFIX,poe.com,AI服务',
                            'DOMAIN-SUFFIX,perplexity.ai,AI服务',
                            // 游戏加速
                            'GEOSITE,steam,游戏加速',
                            'GEOSITE,epicgames,游戏加速',
                            'DOMAIN-SUFFIX,nintendo.net,游戏加速',
                            'DOMAIN-SUFFIX,nintendo.com,游戏加速',
                            'DOMAIN-SUFFIX,xboxlive.com,游戏加速',
                            'DOMAIN-SUFFIX,playstation.com,游戏加速',
                            'DOMAIN-SUFFIX,playstation.net,游戏加速',
                            'DOMAIN-SUFFIX,ea.com,游戏加速',
                            'DOMAIN-SUFFIX,ubisoft.com,游戏加速',
                            'DOMAIN-SUFFIX,blizzard.com,游戏加速',
                            'DOMAIN-SUFFIX,battle.net,游戏加速',
                            // 微软服务
                            'GEOSITE,microsoft,微软服务',
                            'GEOSITE,onedrive,微软服务',
                            'DOMAIN-SUFFIX,copilot.microsoft.com,微软服务',
                            'DOMAIN-SUFFIX,bing.com,微软服务',
                            'DOMAIN-SUFFIX,live.com,微软服务',
                            'DOMAIN-SUFFIX,office.com,微软服务',
                            'DOMAIN-SUFFIX,office365.com,微软服务',
                            // 苹果服务
                            'GEOSITE,apple,苹果服务',
                            'GEOSITE,icloud,苹果服务',
                            'DOMAIN-SUFFIX,apple.com,苹果服务',
                            'DOMAIN-SUFFIX,icloud.com,苹果服务',
                            // 开发者
                            'DOMAIN-SUFFIX,docker.io,开发者',
                            'DOMAIN-SUFFIX,docker.com,开发者',
                            'DOMAIN-SUFFIX,registry.npmjs.org,开发者',
                            'DOMAIN-SUFFIX,npm.pkg.github.com,开发者',
                            'DOMAIN-SUFFIX,pypi.org,开发者',
                            'DOMAIN-SUFFIX,githubusercontent.com,开发者',
                            'DOMAIN-SUFFIX,raw.githubusercontent.com,开发者',
                            'DOMAIN-SUFFIX,aws.amazon.com,开发者',
                            'DOMAIN-SUFFIX,cloudflare.com,开发者',
                            'DOMAIN-SUFFIX,vercel.app,开发者',
                            'DOMAIN-SUFFIX,netlify.app,开发者',
                            // 原有规则
                            'GEOSITE,biliintl,哔哩东南亚',
                            'GEOSITE,ehentai,ehentai',
                            'GEOSITE,github,Github',
                            'GEOSITE,twitter,Twitter',
                            'GEOSITE,youtube,YouTube',
                            'GEOSITE,google,Google',
                            'GEOSITE,telegram,Telegram',
                            'GEOSITE,netflix,NETFLIX',
                            'GEOSITE,bilibili,哔哩哔哩',
                            'GEOSITE,bahamut,巴哈姆特',
                            'GEOSITE,spotify,Spotify',
                            'GEOSITE,geolocation-!cn,others',
                            'GEOIP,google,Google',
                            'GEOIP,netflix,NETFLIX',
                            'GEOIP,telegram,Telegram',
                            'GEOIP,twitter,Twitter',
                            'GEOSITE,pixiv,Pixiv',
                            'GEOSITE,CN,国内',
                            'GEOIP,CN,国内',
                            'MATCH,others'
                        ],
                        dns: {
                            enable: true,
                            listen: ':1053',
                            ipv6: true,
                            'enhanced-mode': 'fake-ip',
                            'fake-ip-range': '28.0.0.1/8',
                            'fake-ip-filter': [
                                '+.lan', '+.local', '+.localhost', '+.invalid',
                                '+.ntp.org', 'time.*.com', 'time.*.gov', 'time.*.edu.cn', 'time.*.apple.com',
                                '+.msftconnecttest.com', '+.msftncsi.com',
                                'localhost.ptlogin2.qq.com', 'localhost.sec.qq.com',
                                '+.stun.*.*', '+.stun.*.*.*', '+.stun.*.*.*.*',
                                'lens.l.google.com', 'stun.l.google.com',
                                '+.srv.nintendo.net', '+.xboxlive.com', '+.battlenet.com.cn',
                                '+.pool.ntp.org', '+.time.edu.cn', '+.ntp.aliyun.com',
                                '+.music.163.com', '+.music.126.net',
                                '+.y.qq.com', '+.api.joox.com',
                                '+.kuwo.cn', '+.kugou.com'
                            ],
                            'default-nameserver': ['223.5.5.5', '119.29.29.29'],
                            'nameserver': ['tls://8.8.4.4#dns', 'tls://1.0.0.1#dns', 'https://dns.google/dns-query#dns'],
                            'proxy-server-nameserver': ['https://doh.pub/dns-query'],
                            'fallback': [
                                'https://1.1.1.1/dns-query',
                                'https://dns.google/dns-query',
                                'tls://8.8.8.8:853'
                            ],
                            'fallback-filter': {
                                geoip: true,
                                'geoip-code': 'CN',
                                ipcidr: ['240.0.0.0/4', '0.0.0.0/32'],
                                domain: ['+.google.com', '+.facebook.com', '+.youtube.com', '+.twitter.com', '+.telegram.org']
                            },
                            'nameserver-policy': {
                                "geosite:cn,private": ["https://doh.pub/dns-query", "https://dns.alidns.com/dns-query"]
                            }
                        },
                        tun: {
                            enable: true,
                            stack: 'system',
                            'dns-hijack': ['any:53'],
                            'auto-route': true,
                            'auto-detect-interface': true
                        }
                    };

                    this.init();
                }

                init() {
                    // 加载持久化数据
                    this.loadData();
                    this.bindEvents();
                    this.initResizeHandler(); // 初始化拖动调整大小
                    this.updateNodeCount();
                    // 初始加载预览面板
                    this.updateLivePreview();
                }

                // 加载本地存储
                loadData() {
                    try {
                        const savedProxies = localStorage.getItem('clash_meta_proxies');
                        if (savedProxies) {
                            this.proxies = JSON.parse(savedProxies);
                            this.renderNodeList();
                        }
                        const savedConfig = localStorage.getItem('clash_meta_config_params');
                        if (savedConfig) {
                            const params = JSON.parse(savedConfig);
                            if (params.subscriptions) this.config.subscriptions = params.subscriptions;
                            this.applyConfigToUI(params);
                        }
                    } catch (e) {
                        console.error('加载本地数据失败:', e);
                    }
                }

                // 保存数据到本地存储
                saveData() {
                    try {
                        localStorage.setItem('clash_meta_proxies', JSON.stringify(this.proxies));
                        // 保存所有主要 UI 配置
                        const configParams = {
                            mixedPort: document.getElementById('mixedPort').value,
                            externalController: document.getElementById('externalController').value,
                            logLevel: document.getElementById('logLevel').value,
                            proxyMode: document.getElementById('proxyMode').value,
                            allowLan: document.getElementById('allowLan').checked,
                            ipv6: document.getElementById('ipv6').checked,
                            dnsEnable: document.getElementById('dnsEnable').checked,
                            tunEnable: document.getElementById('tunEnable').checked,
                            scriptEnable: document.getElementById('scriptEnable').checked,
                            subscriptions: this.config.subscriptions,
                            // 包含部分关键细节
                            tunDevice: document.getElementById('tunDevice').value,
                            tunStack: document.getElementById('tunStack').value,
                            tunMtu: document.getElementById('tunMtu').value
                        };
                        localStorage.setItem('clash_meta_config_params', JSON.stringify(configParams));
                    } catch (e) {
                        console.error('保存数据到本地失败:', e);
                    }
                }

                // 将保存的配置应用回 UI
                applyConfigToUI(params) {
                    if (params.mixedPort) document.getElementById('mixedPort').value = params.mixedPort;
                    if (params.externalController) document.getElementById('externalController').value = params.externalController;
                    if (params.logLevel) document.getElementById('logLevel').value = params.logLevel;
                    if (params.proxyMode) document.getElementById('proxyMode').value = params.proxyMode;
                    if (params.allowLan !== undefined) document.getElementById('allowLan').checked = params.allowLan;
                    if (params.ipv6 !== undefined) document.getElementById('ipv6').checked = params.ipv6;
                    if (params.dnsEnable !== undefined) document.getElementById('dnsEnable').checked = params.dnsEnable;

                    if (params.tunEnable !== undefined) {
                        document.getElementById('tunEnable').checked = params.tunEnable;
                        document.getElementById('tunSettings').style.display = params.tunEnable ? 'block' : 'none';
                        if (params.tunDevice) document.getElementById('tunDevice').value = params.tunDevice;
                        if (params.tunStack) document.getElementById('tunStack').value = params.tunStack;
                        if (params.tunMtu) document.getElementById('tunMtu').value = params.tunMtu;
                    }

                    if (params.scriptEnable !== undefined) {
                        document.getElementById('scriptEnable').checked = params.scriptEnable;
                        document.getElementById('scriptSettings').style.display = params.scriptEnable ? 'block' : 'none';
                    }
                }

                initResizeHandler() {
                    const handle = document.getElementById('resizeHandle');
                    const panel = document.getElementById('previewPanel');

                    if (!handle || !panel) return;

                    let isResizing = false;

                    handle.addEventListener('mousedown', (e) => {
                        isResizing = true;
                        handle.classList.add('dragging');
                        document.body.style.cursor = 'col-resize';
                        document.body.style.userSelect = 'none'; // 防止拖动时选中文字
                    });

                    document.addEventListener('mousemove', (e) => {
                        if (!isResizing) return;

                        // 计算新宽度 (容器宽度 - 鼠标X坐标)
                        // 因为面板在右侧，鼠标往左移(X减小)，宽度增加
                        const containerWidth = document.body.clientWidth;
                        const newPanelWidth = containerWidth - e.clientX;

                        // CSS 中已设置 min-width: 280px, max-width: 800px
                        // 但 JS 中也限制一下以获得更流畅的体验
                        if (newPanelWidth >= 280 && newPanelWidth <= 1200) {
                            panel.style.width = `${newPanelWidth}px`;
                        }
                    });

                    document.addEventListener('mouseup', () => {
                        if (isResizing) {
                            isResizing = false;
                            handle.classList.remove('dragging');
                            document.body.style.cursor = '';
                            document.body.style.userSelect = '';
                        }
                    });
                }

                bindEvents() {
                    // 标签页切换
                    document.querySelectorAll('.editor-tab').forEach(tab => {
                        tab.addEventListener('click', (e) => {
                            const tabId = e.target.dataset.tab;
                            this.switchEditorTab(tabId);
                        });
                    });

                    // 侧边栏按钮
                    document.getElementById('parseLinksBtn').addEventListener('click', () => {
                        this.parseImportLinks();
                    });

                    document.getElementById('addNodeBtn').addEventListener('click', () => {
                        this.showAddNodeModal();
                    });

                    // 基础设置变化
                    const mixedPortEl = document.getElementById('mixedPort');
                    if (mixedPortEl) {
                        mixedPortEl.addEventListener('change', (e) => {
                            this.config['mixed-port'] = parseInt(e.target.value);
                        });
                    }

                    const proxyModeEl = document.getElementById('proxyMode');
                    if (proxyModeEl) {
                        proxyModeEl.addEventListener('change', (e) => {
                            this.config.mode = e.target.value;
                            const sidebarMode = document.getElementById('sidebarProxyMode');
                            if (sidebarMode) sidebarMode.value = e.target.value;
                            this.updateLivePreview(); // 实时更新预览
                        });
                    }

                    // 为所有输入框和选择框添加实时预览监听
                    const settingsInputs = [
                        'mixedPort', 'externalController', 'logLevel', 'allowLan', 'ipv6',
                        'unifiedDelay', 'tcpConcurrent', 'findProcessMode', 'globalClientFingerprint',
                        'geodataMode', 'storeSelected', 'storeFakeIp', 'snifferEnable',
                        'snifferTlsPorts', 'snifferHttpPorts', 'snifferOverrideDestination',
                        // DNS Inputs
                        'dnsEnable', 'dnsListen', 'dnsIpv6', 'dnsEnhancedMode', 'dnsFakeIpRange',
                        'dnsDefaultNameserver', 'dnsNameservers', 'dnsProxyServerNameserver',
                        'dnsFakeIpFilter', 'dnsNameserverPolicy',
                        // TUN Inputs
                        'tunEnable', 'tunDevice', 'tunStack', 'tunDnsHijack', 'tunMtu',
                        'tunAutoRoute', 'tunAutoDetect', 'tunStrictRoute', 'tunIncludedRoutes', 'tunExcludedRoutes',
                        // Script Inputs
                        'scriptEnable', 'profileUrl', 'profileUpdateInterval', 'preprocessorScript', 'postprocessorScript'
                    ];

                    const keyMap = {
                        'mixedPort': 'mixed-port:',
                        'proxyMode': 'mode:',
                        'logLevel': 'log-level:',
                        'allowLan': 'allow-lan:',
                        'ipv6': 'ipv6:',
                        'unifiedDelay': 'unified-delay:',
                        'tcpConcurrent': 'tcp-concurrent:',
                        'externalController': 'external-controller:',
                        'findProcessMode': 'find-process-mode:',
                        'globalClientFingerprint': 'global-client-fingerprint:',
                        'geodataMode': 'geodata-mode:',
                        'storeSelected': 'store-selected:',
                        'storeFakeIp': 'store-fake-ip:',
                        'snifferEnable': 'sniffer:',
                        'snifferTlsPorts': 'TLS:',
                        'snifferHttpPorts': 'HTTP:',
                        'snifferOverrideDestination': 'override-destination:',
                        // DNS Keys
                        'dnsEnable': 'dns:',
                        'dnsListen': 'listen:',
                        'dnsIpv6': 'ipv6:',
                        'dnsEnhancedMode': 'enhanced-mode:',
                        'dnsFakeIpRange': 'fake-ip-range:',
                        'dnsDefaultNameserver': 'default-nameserver:',
                        'dnsNameservers': 'nameserver:',
                        'dnsProxyServerNameserver': 'proxy-server-nameserver:',
                        'dnsFakeIpFilter': 'fake-ip-filter:',
                        'dnsNameserverPolicy': 'nameserver-policy:',
                        // TUN Keys
                        'tunEnable': 'tun:',
                        'tunDevice': 'device:',
                        'tunStack': 'stack:',
                        'tunDnsHijack': 'dns-hijack:',
                        'tunMtu': 'mtu:',
                        'tunAutoRoute': 'auto-route:',
                        'tunAutoDetect': 'auto-detect-interface:',
                        'tunStrictRoute': 'strict-route:',
                        'tunIncludedRoutes': 'include-package:',
                        'tunExcludedRoutes': 'exclude-package:',
                        // Script Keys (assuming standard Clash Meta script syntax or similar)
                        'scriptEnable': 'script:',
                        // Note: Profile URL etc might be internal or specific fields.
                        // If they don't map to standard keys, we just point to the top level or omitting.
                        // Letting them trigger update is the most important part.
                        'profileUrl': '#',
                        'profileUpdateInterval': '#',
                        'preprocessorScript': '#',
                        'postprocessorScript': '#'
                    };

                    settingsInputs.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) {
                            const eventType = el.type === 'checkbox' ? 'change' : 'input';
                            el.addEventListener(eventType, () => {
                                // 同步更新配置对象（如果是基础字段）
                                if (id === 'mixedPort') this.config['mixed-port'] = parseInt(el.value);
                                if (id === 'proxyMode') this.config.mode = el.value;
                                this.updateLivePreview(keyMap[id]);
                            });
                        }
                    });

                    // 多格式预览切换 (Select事件)
                    this.currentPreviewFormat = 'clash-meta';
                    const formatSelect = document.getElementById('previewFormatSelect');
                    if (formatSelect) {
                        formatSelect.addEventListener('change', (e) => {
                            this.currentPreviewFormat = e.target.value;
                            this.updateLivePreview();
                        });
                    }

                    // 复制预览按钮
                    document.getElementById('copyPreviewBtn').addEventListener('click', () => {
                        const content = this.getPreviewContent();
                        navigator.clipboard.writeText(content)
                            .then(() => this.showStatus(`✅ ${this.currentPreviewFormat} 配置已复制`, 'success'))
                            .catch(() => this.showStatus('复制失败', 'error'));
                    });

                    // 下载预览按钮
                    // 下载预览按钮
                    document.getElementById('downloadPreviewBtn').addEventListener('click', () => {
                        const content = this.getPreviewContent();
                        const format = this.currentPreviewFormat;
                        const extMap = {
                            'clash-meta': '.yaml',
                            'sing-box': '.json',
                            'surge': '.conf',
                            'stash': '.yaml',
                            'quantumultx': '.conf',
                            'loon': '.conf',
                            'shadowrocket': '.txt', // Base64 or URI list
                            'nekoray': '.json',
                            'v2ray': '.json',
                            'v2rayng': '.txt'
                        };
                        const mimeMap = {
                            'clash-meta': 'text/yaml',
                            'sing-box': 'application/json',
                            'surge': 'text/plain',
                            'stash': 'text/yaml',
                            'quantumultx': 'text/plain',
                            'loon': 'text/plain',
                            'shadowrocket': 'text/plain',
                            'nekoray': 'application/json',
                            'v2ray': 'application/json',
                            'v2rayng': 'text/plain'
                        };

                        const blob = new Blob([content], { type: mimeMap[format] || 'text/plain' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `config${extMap[format] || '.txt'}`;
                        a.click();
                        URL.revokeObjectURL(url);
                        this.showStatus(`${format} 配置已下载`, 'success');
                    });

                    // 节点编辑按钮
                    document.getElementById('saveNodeBtn').addEventListener('click', () => {
                        this.saveNode();
                    });

                    // 延迟测速 & 连通性测试
                    document.getElementById('testLatencyBtn').addEventListener('click', () => {
                        // 默认测 Google Generate 204
                        this.performConnectivityTest('http://www.gstatic.com/generate_204');
                    });

                    document.getElementById('testConnectivityBtn').addEventListener('click', () => {
                        this.showConnectivityModal();
                    });

                    document.getElementById('startConnectivityTestBtn').addEventListener('click', () => {
                        const url = document.getElementById('testTargetUrl').value || 'http://www.gstatic.com/generate_204';
                        this.performConnectivityTest(url);
                    });

                    document.getElementById('cancelEditBtn').addEventListener('click', () => {
                        this.cancelEdit();
                    });

                    // 节点编辑实时预览监听
                    const nodeEditor = document.getElementById('currentNodeEditor');
                    if (nodeEditor) {
                        const handler = (e) => {
                            if (['INPUT', 'SELECT', 'TEXTAREA'].includes(e.target.tagName)) {
                                // 尝试获取当前正在编辑的节点名称作为定位锚点
                                const nameInput = document.getElementById('editNodeName');
                                const currentName = nameInput ? nameInput.value.trim() : '';
                                // 如果有名称，构造 "name: 节点名" 格式的定位键
                                const targetKey = currentName ? `name: ${this.quoteYaml(currentName)}` : null;
                                this.updateLivePreview(targetKey);
                            }
                        };
                        nodeEditor.addEventListener('input', handler);
                        nodeEditor.addEventListener('change', handler);
                        this.updateTlsVis = () => {
                            const elTls = document.getElementById('editNodeTls');
                            const elReality = document.getElementById('editNodeReality');
                            const elEch = document.getElementById('editNodeEch');

                            const t = elTls ? elTls.checked : false;
                            const r = elReality ? elReality.checked : false;
                            const e = elEch ? elEch.checked : false;

                            const elTlsSettings = document.getElementById('tlsSettings');
                            if (elTlsSettings) elTlsSettings.style.display = (t || r || e) ? 'block' : 'none';

                            const elRealitySettings = document.getElementById('realitySettings');
                            if (elRealitySettings) elRealitySettings.style.display = r ? 'block' : 'none';

                            const elEchSet = document.getElementById('echSettings');
                            if (elEchSet) elEchSet.style.display = e ? 'block' : 'none';
                        };

                        document.getElementById('editNodeTls').addEventListener('change', this.updateTlsVis.bind(this));
                        document.getElementById('editNodeReality').addEventListener('change', this.updateTlsVis.bind(this));
                        const elEchToggle = document.getElementById('editNodeEch');
                        if (elEchToggle) elEchToggle.addEventListener('change', this.updateTlsVis.bind(this));

                        // 协议类型变化
                        document.getElementById('editNodeType').addEventListener('change', (e) => {
                            this.showProtocolForm(e.target.value);
                            this.updateNetworkSettings(e.target.value);
                            this.updateTlsVis();
                        });
                    }

                    // 传输协议变化
                    document.getElementById('editNodeNetwork').addEventListener('change', (e) => {
                        const value = e.target.value;
                        document.getElementById('wsSettings').style.display = value === 'ws' ? 'block' : 'none';
                        document.getElementById('grpcSettings').style.display = value === 'grpc' ? 'block' : 'none';
                        document.getElementById('httpSettings').style.display = value === 'http' ? 'block' : 'none';
                        this.updateLivePreview(); // 实时更新预览
                    });

                    // 节点编辑表单实时预览监听
                    // 注意：已在 nodeEditor 的事件委托中统一处理，移除此处冗余且问题逻辑（避免使用旧名称 updatePreview）

                    // 策略组按钮
                    document.getElementById('addProxyGroupBtn').addEventListener('click', () => {
                        this.addProxyGroup();
                    });

                    // 全选功能
                    document.getElementById('selectAllNodes').addEventListener('change', (e) => {
                        const checkboxes = document.querySelectorAll('.node-checkbox');
                        checkboxes.forEach(cb => cb.checked = e.target.checked);
                    });

                    // 批量删除按钮
                    document.getElementById('deleteSelectedBtn').addEventListener('click', () => {
                        this.deleteSelectedNodes();
                    });

                    // 新增:导出链接按钮
                    document.getElementById('exportLinksBtn').addEventListener('click', () => {
                        this.exportSelectedLinks();
                    });

                    // 批量二维码按钮
                    document.getElementById('batchQRCodeBtn').addEventListener('click', () => {
                        this.showBatchQRCodes();
                    });

                    // 订阅管理监听
                    document.getElementById('addSubBtn').addEventListener('click', () => this.showAddSubModal());
                    document.getElementById('updateAllSubsBtn').addEventListener('click', () => this.updateAllSubscriptions());
                    document.getElementById('resetAllSubsBtn').addEventListener('click', () => this.resetAllSubscriptions());

                    // 批量工具监听
                    document.getElementById('applyBatchNamingBtn').addEventListener('click', () => this.applyBatchNaming());
                    document.getElementById('applyBatchFilterBtn').addEventListener('click', () => this.applyBatchFiltering());

                    // 批量工具实时预览监听
                    ['batchPrefix', 'batchRenameRegex', 'keepKeywords', 'dropKeywords'].forEach(id => {
                        const el = document.getElementById(id);
                        if (el) {
                            el.addEventListener('input', () => this.updateLivePreview('proxies:'));
                        }
                    });
                    document.getElementById('clearAllNodesBtn').addEventListener('click', () => {
                        if (confirm('确定要清空所有节点吗？')) {
                            this.proxies = [];
                            this.renderNodeList();
                            this.updateNodeCount();
                            this.saveData();
                            this.updateLivePreview(); // 实时更新预览
                            this.showStatus('已清空所有节点', 'success');
                        }
                    });

                    document.getElementById('removeDuplicatesBtn').addEventListener('click', () => this.removeDuplicateNodes());
                    document.getElementById('sortByLatencyBtn').addEventListener('click', () => this.sortByLatency());

                    // 规则按钮
                    document.getElementById('addRuleBtn').addEventListener('click', () => {
                        this.addRule();
                    });

                    document.getElementById('clearRulesBtn').addEventListener('click', () => {
                        if (confirm('确定要清空所有规则吗？')) {
                            document.getElementById('customRules').value = '';
                            this.config.rules = [];
                            this.updateLivePreview(); // 实时更新预览
                        }
                    });

                    document.getElementById('importRulesBtn').addEventListener('click', () => {
                        this.importRules();
                    });

                    // 规则文本框实时更新
                    const customRulesEl = document.getElementById('customRules');
                    if (customRulesEl) {
                        customRulesEl.addEventListener('input', () => {
                            this.updateLivePreview('rules:');
                        });
                    }

                    // DNS/TUN/Script 开关监听补全
                    ['dnsEnable', 'dnsListen', 'dnsIpv6', 'dnsEnhancedMode', 'dnsFakeIpRange'].forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.addEventListener(el.type === 'checkbox' ? 'change' : 'input', () => this.updateLivePreview('dns:'));
                    });

                    // TUN开关
                    document.getElementById('tunEnable').addEventListener('change', (e) => {
                        document.getElementById('tunSettings').style.display = e.target.checked ? 'block' : 'none';
                        this.config.tun.enable = e.target.checked;
                        this.updateLivePreview('tun:');
                    });

                    ['tunDevice', 'tunStack', 'tunMtu', 'tunAutoRoute', 'tunAutoDetect', 'tunStrictRoute'].forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.addEventListener(el.type === 'checkbox' ? 'change' : 'input', () => this.updateLivePreview('tun:'));
                    });

                    // 脚本开关
                    document.getElementById('scriptEnable').addEventListener('change', (e) => {
                        document.getElementById('scriptSettings').style.display = e.target.checked ? 'block' : 'none';
                        if (this.config.script) this.config.script.enable = e.target.checked;
                        this.updateLivePreview('script:');
                    });

                    // 初始加载订阅渲染
                    this.renderSubscriptions();
                }

                // --- Sub-Store 业务方法注入 ---

                renderSubscriptions() {
                    const container = document.getElementById('subsListContainer');
                    if (!container) return;
                    if (!this.config.subscriptions || this.config.subscriptions.length === 0) {
                        container.innerHTML = `<div class="empty-state"><i class="fas fa-rss"></i><p>您尚未添加任何订阅源。点击“添加订阅源”开始同步。</p></div>`;
                        return;
                    }
                    container.innerHTML = this.config.subscriptions.map((sub, index) => {
                        const hasRule = sub.prefix || sub.include || sub.exclude;
                        return `
                        <div class="sub-card" style="position: relative; padding: 15px; background: white; border: 1px solid var(--border); border-radius: 8px; opacity: ${sub.isSyncing ? '0.7' : '1'}">
                            <div class="sub-card-title" style="font-weight: 600; font-size: 14px; margin-bottom: 5px; display: flex; align-items: center; gap: 8px;">
                                <i class="fas ${sub.isSyncing ? 'fa-spinner fa-spin' : 'fa-rss'}" style="color: var(--primary);"></i> ${sub.name}
                            </div>
                            <div class="sub-card-url" style="font-size: 11px; word-break: break-all; color: var(--text-secondary); margin-bottom: 8px;">${sub.url}</div>
                            
                            ${hasRule ? `
                            <div class="sub-rules" style="background: #f8f9fa; padding: 6px 10px; border-radius: 4px; margin-bottom: 8px; font-size: 11px;">
                                ${sub.prefix ? `<div title="统称前缀"><i class="fas fa-tag"></i> Prefix: <b>${sub.prefix}</b></div>` : ''}
                                ${sub.include ? `<div title="包含关键词"><i class="fas fa-filter"></i> Keep: <b>${sub.include}</b></div>` : ''}
                                ${sub.exclude ? `<div title="排除关键词"><i class="fas fa-minus-circle"></i> Drop: <b>${sub.exclude}</b></div>` : ''}
                            </div>
                            ` : ''}

                            <div class="sub-card-footer" style="display: flex; justify-content: space-between; align-items: center; border-top: 1px solid #eee; padding-top: 8px; margin-top: 5px;">
                                <span style="font-size: 11px; color: var(--text-secondary);">最后同步: ${sub.updated ? sub.updated.split(' ')[1] || sub.updated : '暂无'}</span>
                                <div class="sub-card-actions" style="display: flex; gap: 5px;">
                                    <button class="btn btn-sm btn-icon" 
                                        onclick="window.metaEditor.updateSingleSubscription(${index})" 
                                        ${sub.isSyncing ? 'disabled' : ''} 
                                        title="立即同步">
                                        <i class="fas fa-sync ${sub.isSyncing ? 'fa-spin' : ''}"></i>
                                    </button>
                                    <button class="btn btn-sm btn-icon" 
                                        style="color: var(--danger);" 
                                        onclick="window.metaEditor.deleteSubscription(${index})" 
                                        ${sub.isSyncing ? 'disabled' : ''} 
                                        title="删除">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                    }).join('');
                }

                showAddSubModal() {
                    document.getElementById('addSubModal').style.display = 'flex';
                    document.getElementById('newSubName').value = '';
                    document.getElementById('newSubUrl').value = '';
                    document.getElementById('newSubPrefix').value = '';
                    document.getElementById('newSubInclude').value = '';
                    document.getElementById('newSubExclude').value = '';
                }

                confirmAddSub() {
                    const baseName = document.getElementById('newSubName').value.trim();
                    const urlInput = document.getElementById('newSubUrl').value.trim();
                    const prefix = document.getElementById('newSubPrefix').value.trim();
                    const include = document.getElementById('newSubInclude').value.trim();
                    const exclude = document.getElementById('newSubExclude').value.trim();

                    if (!urlInput) {
                        this.showStatus('请填写订阅 URL', 'error');
                        return;
                    }

                    const urls = urlInput.split('\n').map(u => u.trim()).filter(u => u && u.startsWith('http'));
                    if (urls.length === 0) {
                        this.showStatus('预览框中未发现有效的 http/https 链接', 'error');
                        return;
                    }

                    urls.forEach((url, idx) => {
                        const name = urls.length > 1 ? `${baseName || '订阅'} ${idx + 1}` : (baseName || '我的订阅');
                        this.config.subscriptions.push({
                            name,
                            url,
                            prefix: prefix || '',
                            include: include || '',
                            exclude: exclude || '',
                            updated: null
                        });
                    });

                    this.saveData();
                    this.renderSubscriptions();
                    document.getElementById('addSubModal').style.display = 'none';
                    this.showStatus(`已成功添加 ${urls.length} 个订阅源`, 'success');
                }

                deleteSubscription(index) {
                    if (confirm('确定移除该订阅源？')) {
                        this.config.subscriptions.splice(index, 1);
                        this.saveData();
                        this.renderSubscriptions();
                    }
                }

                async updateSingleSubscription(index) {
                    const sub = this.config.subscriptions[index];
                    if (sub.isSyncing) return;

                    sub.isSyncing = true;
                    this.renderSubscriptions();
                    this.showStatus(`正在拉取: ${sub.name}`, 'info');

                    try {
                        const content = await this.fetchSubscription(sub.url);
                        if (content) {
                            const result = this.parser.parseSubscription(content);
                            if (result.proxies && result.proxies.length > 0) {
                                let addedCount = 0;
                                let filteredCount = 0;

                                // 规则提取
                                const includeKeys = sub.include ? sub.include.split(/[ ,|]/).filter(v => v) : [];
                                const excludeKeys = sub.exclude ? sub.exclude.split(/[ ,|]/).filter(v => v) : [];

                                result.proxies.forEach(p => {
                                    // 1. 应用源级过滤
                                    const nameLow = p.name.toLowerCase();
                                    if (includeKeys.length > 0 && !includeKeys.some(k => nameLow.includes(k.toLowerCase()))) {
                                        filteredCount++;
                                        return;
                                    }
                                    if (excludeKeys.length > 0 && excludeKeys.some(k => nameLow.includes(k.toLowerCase()))) {
                                        filteredCount++;
                                        return;
                                    }

                                    // 2. 应用源级前缀
                                    if (sub.prefix && !p.name.startsWith(sub.prefix)) {
                                        p.name = sub.prefix + p.name;
                                    }

                                    // 3. 全局去重并添加
                                    const isDup = this.proxies.some(existing =>
                                        existing.server === p.server &&
                                        existing.port === p.port &&
                                        existing.type === p.type
                                    );
                                    if (!isDup) {
                                        this.addProxy(p);
                                        addedCount++;
                                    }
                                });

                                sub.updated = new Date().toLocaleString();
                                this.saveData();
                                this.showStatus(`${sub.name} 同步完成: 新增 ${addedCount} 个${filteredCount > 0 ? `, 过滤 ${filteredCount} 个` : ''}`, 'success');
                            } else {
                                this.showStatus(`${sub.name} 未找到有效节点`, 'warning');
                            }
                        }
                    } catch (e) {
                        this.showStatus(`${sub.name} 同步失败: ${e.message}`, 'error');
                    } finally {
                        sub.isSyncing = false;
                        this.renderSubscriptions();
                    }
                }

                async updateAllSubscriptions() {
                    const subs = this.config.subscriptions;
                    if (subs.length === 0) {
                        this.showStatus('没有可更新的订阅', 'warning');
                        return;
                    }

                    this.showStatus(`开始全量同步 ${subs.length} 个订阅...`, 'info');

                    // 并行更新所有订阅
                    const promises = subs.map((_, index) => this.updateSingleSubscription(index));

                    const results = await Promise.allSettled(promises);

                    const successCount = results.filter(r => r.status === 'fulfilled').length;
                    const failCount = results.length - successCount;

                    if (failCount === 0) {
                        this.showStatus(`所有 ${successCount} 个订阅同步完成`, 'success');
                    } else {
                        this.showStatus(`同步完成: 成功 ${successCount} 个, 失败 ${failCount} 个`, 'warning');
                    }
                }

                resetAllSubscriptions() {
                    if (this.config.subscriptions) {
                        this.config.subscriptions.forEach(sub => sub.isSyncing = false);
                        this.renderSubscriptions();
                        this.showStatus('已重置所有订阅库同步状态', 'info');
                    }
                }

                async fetchWithTimeout(url, options = {}, timeout = 10000) {
                    const controller = new AbortController();
                    const id = setTimeout(() => controller.abort(), timeout);
                    try {
                        const response = await fetch(url, { ...options, signal: controller.signal });
                        clearTimeout(id);
                        return response;
                    } catch (e) {
                        clearTimeout(id);
                        throw e;
                    }
                }

                async fetchSubscription(url) {
                    let text = '';
                    let success = false;
                    const timeout = 10000;

                    // 1. 直连
                    try {
                        const response = await this.fetchWithTimeout(url, {}, timeout);
                        if (response.ok) { text = await response.text(); success = true; }
                    } catch (e) { }

                    // 2. 代理 A
                    if (!success) {
                        try {
                            const res = await this.fetchWithTimeout(`https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`, {}, timeout);
                            if (res.ok) { text = await res.text(); success = true; }
                        } catch (e) { }
                    }

                    // 3. 代理 B
                    if (!success) {
                        try {
                            const res = await this.fetchWithTimeout(`https://corsproxy.io/?${encodeURIComponent(url)}`, {}, timeout);
                            if (res.ok) { text = await res.text(); success = true; }
                        } catch (e) { }
                    }

                    if (!success) throw new Error('同步超时或 CORS 代理失效，请稍后重试或手动导入');
                    return text;
                }

                applyBatchNaming() {
                    const prefix = document.getElementById('batchPrefix').value.trim();
                    const suffix = document.getElementById('batchSuffix').value.trim();
                    const regexVal = document.getElementById('batchRenameRegex').value.trim();
                    let count = 0;

                    // 记录名称映射，用于同步更新策略组
                    const nameMap = new Map();

                    this.proxies.forEach((p, index) => {
                        const oldName = p.name;
                        let newName = oldName;

                        // 1. 正则替换
                        if (regexVal && regexVal.includes('|')) {
                            const parts = regexVal.split('|');
                            const find = parts[0];
                            const replace = parts[1] || '';
                            try {
                                newName = newName.replace(new RegExp(find, 'g'), replace);
                            } catch (e) {
                                console.error('正则替换错误:', e);
                            }
                        }

                        // 2. 添加前缀
                        if (prefix && !newName.startsWith(prefix)) {
                            newName = prefix + newName;
                        }

                        // 3. 添加后缀
                        if (suffix && !newName.endsWith(suffix)) {
                            newName = newName + suffix;
                        }

                        // 4. 处理 # 号为序号 (例如: "Node #" -> "Node 1")
                        if (newName.includes('#')) {
                            newName = newName.replace(/#/g, index + 1);
                        }

                        if (newName !== oldName) {
                            p.name = newName;
                            nameMap.set(oldName, newName);
                            count++;
                        }
                    });

                    // 同步更新所有策略组中的名称引用
                    if (nameMap.size > 0 && this.config['proxy-groups']) {
                        this.config['proxy-groups'].forEach(group => {
                            if (group.proxies && Array.isArray(group.proxies)) {
                                group.proxies = group.proxies.map(n => nameMap.get(n) || n);
                            }
                        });
                    }

                    this.renderNodeList();
                    this.saveData();

                    // 清空输入框，防止再次应用
                    document.getElementById('batchPrefix').value = '';
                    document.getElementById('batchRenameRegex').value = '';

                    this.updateLivePreview(); // 实时更新预览
                    this.showStatus(`成功处理 ${count} 个节点名称并同步更新策略组`, 'success');
                }

                applyBatchFiltering() {
                    const keep = document.getElementById('keepKeywords').value.trim().split('\n').filter(x => x);
                    const drop = document.getElementById('dropKeywords').value.trim().split('\n').filter(x => x);
                    const oldLen = this.proxies.length;
                    this.proxies = this.proxies.filter(p => {
                        const name = p.name.toLowerCase();
                        if (keep.length > 0 && !keep.some(k => name.includes(k.toLowerCase()))) return false;
                        if (drop.length > 0 && drop.some(k => name.includes(k.toLowerCase()))) return false;
                        return true;
                    });
                    this.renderNodeList();
                    this.updateNodeCount();
                    this.saveData();

                    // 清空输入框
                    document.getElementById('keepKeywords').value = '';
                    document.getElementById('dropKeywords').value = '';

                    this.updateLivePreview(); // 过滤后刷新
                    this.showStatus(`过滤完成，移除 ${oldLen - this.proxies.length} 个节点`, 'success');
                }

                removeDuplicateNodes() {
                    const oldLen = this.proxies.length;
                    const seen = new Set();
                    this.proxies = this.proxies.filter(p => {
                        // 根据服务器地址、端口、协议类型
                        let key = `${p.type}:${p.server}:${p.port}`;

                        // 加上核心凭证，避免不同账号在同一服务器上被误删
                        if (p.uuid) key += `:${p.uuid}`;
                        else if (p.password) key += `:${p.password}`;
                        else if (p.psk) key += `:${p.psk}`;
                        else if (p['private-key']) key += `:${p['private-key']}`;

                        // 对于 Hysteria2 等可能有 user/auth
                        if (p.auth) key += `:${p.auth}`;

                        if (seen.has(key)) return false;
                        seen.add(key);
                        return true;
                    });
                    this.renderNodeList();
                    this.updateNodeCount();
                    this.saveData();
                    this.updateLivePreview(); // 去重后刷新
                    this.showStatus(`去重完成，移除 ${oldLen - this.proxies.length} 个重复节点`, 'success');
                }

                sortByLatency() {
                    this.proxies.sort((a, b) => {
                        const latA = a.latency === 0 || a.latency === undefined ? 999999 : a.latency;
                        const latB = b.latency === 0 || b.latency === undefined ? 999999 : b.latency;
                        return latA - latB;
                    });
                    this.renderNodeList();
                    this.saveData();
                    this.updateLivePreview(); // 实时更新预览
                    this.showStatus('已按延迟从低到高排序 (无数据排最后)', 'success');
                }

                // 更新节点列表中的延迟显示
                updateLatencyUI(index, latency) {
                    const nodeItem = document.querySelector(`.node-item[data-index="${index}"]`);
                    if (!nodeItem) return;

                    const latencySpan = nodeItem.querySelector('.latency');
                    if (!latencySpan) return;

                    // 更新数据
                    this.proxies[index].latency = latency;

                    if (latency === 0 || latency === -1) {
                        latencySpan.textContent = '延迟: 超时';
                        latencySpan.className = 'latency timeout';
                    } else if (latency === -2) {
                        latencySpan.textContent = '未运行'; // 核心中未找到
                        latencySpan.className = 'latency';
                        latencySpan.style.color = '#999';
                    } else if (latency === -3) {
                        latencySpan.textContent = '错误';
                        latencySpan.className = 'latency timeout';
                    } else {
                        latencySpan.textContent = `延迟: ${latency}ms`;
                        latencySpan.className = 'latency ' + (latency < 100 ? 'low' : latency < 200 ? 'medium' : 'high');
                    }
                }

                showConnectivityModal() {
                    document.getElementById('connectivityModal').style.display = 'flex';
                }

                async performConnectivityTest(targetUrl) {
                    const apiUrl = document.getElementById('testApiUrl').value.replace(/\/$/, '');
                    const apiSecret = document.getElementById('testApiSecret').value;

                    const headers = {};
                    if (apiSecret) {
                        headers['Authorization'] = `Bearer ${apiSecret}`;
                    }

                    this.showStatus('正在连接 Clash Core...', 'info');

                    try {
                        // 1. 获取 Core 中运行的代理列表
                        const res = await fetch(`${apiUrl}/proxies`, { headers });
                        if (!res.ok) throw new Error(`无法连接 Core (Web API Status: ${res.status})`);

                        const data = await res.json();
                        const runningProxies = data.proxies; // Map: Name -> ProxyInfo

                        this.showStatus(`连接成功，开始测试此配置中的 ${this.proxies.length} 个节点...`, 'info');
                        document.getElementById('connectivityModal').style.display = 'none';

                        // 2. 遍历本地节点进行测试
                        // 并发控制：每批 10 个
                        const batchSize = 10;
                        const validProxies = this.proxies.map((p, i) => ({ ...p, _index: i }));

                        for (let i = 0; i < validProxies.length; i += batchSize) {
                            const batch = validProxies.slice(i, i + batchSize);
                            const promises = batch.map(async (p) => {
                                const index = p._index;
                                const proxyName = p.name;

                                // 检查 Core 中是否存在该名称的代理
                                if (!runningProxies[proxyName]) {
                                    this.updateLatencyUI(index, -2); // -2: 未运行/未找到
                                    return;
                                }

                                // 触发延迟测试
                                try {
                                    const encodedName = encodeURIComponent(proxyName);
                                    const testUrl = `${apiUrl}/proxies/${encodedName}/delay?timeout=5000&url=${encodeURIComponent(targetUrl)}`;

                                    const testRes = await fetch(testUrl, { headers });
                                    if (!testRes.ok) {
                                        this.updateLatencyUI(index, 0); // 0: 超时/失败
                                        return;
                                    }

                                    const testData = await testRes.json();
                                    const delay = testData.delay;
                                    this.updateLatencyUI(index, delay);

                                } catch (e) {
                                    console.error(`Test failed for ${proxyName}:`, e);
                                    this.updateLatencyUI(index, -3); // -3: 测试请求错误
                                }
                            });

                            await Promise.allSettled(promises);
                        }

                        this.showStatus('测试完成', 'success');
                        this.saveData(); // 保存延迟数据

                    } catch (e) {
                        console.error(e);
                        this.showStatus(`测试失败: ${e.message}. 请检查 Clash 是否开启了 External Controller。`, 'error');
                    }
                }

                // 解析导入的链接
                async parseImportLinks() {
                    const input = document.getElementById('importLinks').value.trim();
                    if (!input) {
                        this.showStatus('请输入链接内容', 'error');
                        return;
                    }

                    this.showStatus('正在解析...', 'info');

                    try {
                        const lowerInput = input.toLowerCase();
                        const containsKey = (key) => lowerInput.includes(key);
                        const isYAML = containsKey('name:') ||
                            containsKey('proxies:') ||
                            containsKey('roxies:') ||
                            input.includes('- {') ||
                            input.trim().startsWith('- ');
                        const isJSON = input.startsWith('{') || (input.startsWith('[') && (input.includes('"protocol"') || input.includes('"server"')));

                        if (isYAML || isJSON || (!input.includes('\n') && !input.startsWith('vmess://') && !input.startsWith('vless://') &&
                            !input.startsWith('ss://') && !input.startsWith('trojan://') && !input.startsWith('ssr://'))) {

                            // 处理各种 YAML / JSON 或 单个配置块
                            if (isYAML || isJSON) {
                                const result = this.parser.parseSubscription(input);
                                console.log('YAML/JSON 解析结果:', result);
                                if (result.proxies.length > 0) {
                                    result.proxies.forEach(proxy => this.addProxy(proxy));
                                    this.showStatus(`成功导入 ${result.proxies.length} 个节点`, 'success');
                                    document.getElementById('importLinks').value = '';
                                    return;
                                } else if (isYAML) {
                                    // 如果识别为 YAML 但没有解析出节点，不要继续执行下面的批量链接解析，直接报错
                                    this.showStatus('YAML 格式解析失败，请检查缩进或必填字段', 'error');
                                    return;
                                }
                            }

                            // 可能是订阅链接
                            if (input.startsWith('http://') || input.startsWith('https://')) {
                                await this.fetchAndParseSubscription(input);
                                return;
                            }
                        }

                        // 批量解析普通链接
                        const lines = input.split('\n').map(l => l.trim()).filter(l => l);
                        const allProxies = [];
                        const allErrors = [];

                        for (const line of lines) {
                            try {
                                const result = this.parser.parseAnyLink(line);
                                allProxies.push(result);
                            } catch (e) {
                                if (e.message === 'SUBSCRIPTION_URL') {
                                    // 处理订阅链接
                                    await this.fetchAndParseSubscription(line);
                                } else {
                                    allErrors.push(e.message);
                                }
                            }
                        }

                        if (allErrors.length > 0) {
                            this.showStatus(`部分解析失败: ${allErrors[0]}`, 'warning');
                        }

                        if (allProxies.length > 0) {
                            allProxies.forEach(proxy => this.addProxy(proxy));
                            this.showStatus(`成功导入 ${allProxies.length} 个节点`, 'success');
                            document.getElementById('importLinks').value = '';
                        } else if (allErrors.length === 0) {
                            // 已经在 fetch 中处理或没找到内容
                        } else {
                            this.showStatus('未能解析到有效节点', 'error');
                        }

                    } catch (error) {
                        this.showStatus(`解析过程中出错: ${error.message}`, 'error');
                    }
                }

                // 获取并解析订阅链接
                async fetchAndParseSubscription(url) {
                    this.showStatus('正在获取订阅内容...', 'info');
                    const timeout = 15000;
                    try {
                        let text = '';
                        let success = false;

                        // 1. 尝试直接获取
                        try {
                            const response = await this.fetchWithTimeout(url, {}, timeout);
                            if (response.ok) {
                                text = await response.text();
                                success = true;
                            }
                        } catch (e) {
                            console.warn('直接获取失败，准备尝试代理...', e);
                        }

                        // 2. 代理 A
                        if (!success) {
                            try {
                                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                                this.showStatus('尝试利用代理 A 获取...', 'info');
                                const response = await this.fetchWithTimeout(proxyUrl, {}, timeout);
                                if (response.ok) {
                                    text = await response.text();
                                    success = true;
                                }
                            } catch (e) {
                                console.warn('代理 A 获取失败...', e);
                            }
                        }

                        // 3. 代理 B
                        if (!success) {
                            try {
                                const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                                this.showStatus('尝试利用代理 B 获取...', 'info');
                                const response = await this.fetchWithTimeout(proxyUrl, {}, timeout);
                                if (response.ok) {
                                    text = await response.text();
                                    success = true;
                                }
                            } catch (e) {
                                console.warn('代理 B 获取失败...', e);
                            }
                        }

                        if (!success) {
                            throw new Error('所有尝试均已失败 (超时或 CORS 限制)');
                        }

                        const result = this.parser.parseSubscription(text);

                        if (result.proxies.length > 0) {
                            result.proxies.forEach(proxy => this.addProxy(proxy));
                            this.showStatus(`从订阅成功导入 ${result.proxies.length} 个节点`, 'success');
                            document.getElementById('importLinks').value = '';
                        } else {
                            this.showStatus('订阅内容中未找到有效节点', 'error');
                        }
                    } catch (error) {
                        const msg = `订阅获取失败: ${error.message}。
建议：
1. 请直接在浏览器打开订阅链接。
2. 复制页面显示的所有内容。
3. 返回此处，直接在导入框中粘贴并解析。`;
                        this.showStatus(msg, 'error');
                        console.error('Fetch Error:', error);
                    }
                }

                // 添加节点
                addProxy(proxy) {
                    // 防止重复导入：检查是否已存在相同 Server + Port + Type 的节点
                    const isDuplicate = this.proxies.some(p =>
                        p.server === proxy.server &&
                        p.port === proxy.port &&
                        p.type === proxy.type
                    );

                    if (isDuplicate) {
                        console.log(`跳过重复节点: ${proxy.name} (${proxy.server}:${proxy.port})`);
                        return;
                    }

                    // 确保名称唯一
                    let baseName = proxy.name;
                    let counter = 1;
                    while (this.proxies.some(p => p.name === proxy.name)) {
                        proxy.name = `${baseName} (${counter})`;
                        counter++;
                    }

                    // 设置默认值
                    if (!proxy.udp && proxy.type !== 'http' && proxy.type !== 'socks5') {
                        proxy.udp = true;
                    }

                    this.proxies.push(proxy);
                    this.renderNodeList();
                    this.updateNodeCount();

                    // 更新策略组
                    if (this.config['proxy-groups'][0].proxies) {
                        this.config['proxy-groups'][0].proxies = this.proxies.map(p => p.name);
                    }
                    if (this.config['proxy-groups'][3].proxies) {
                        this.config['proxy-groups'][3].proxies = this.proxies.map(p => p.name);
                    }

                    // 实时更新预览并定位到新节点 (使用 '  - name:' 定位定义而非引用)
                    this.updateLivePreview(`  - name: ${proxy.name}`);
                }

                // 渲染节点列表
                renderNodeList() {
                    const nodeList = document.getElementById('nodeList');

                    if (this.proxies.length === 0) {
                        nodeList.innerHTML = `
                        <div style="text-align: center; padding: 30px; color: #6c757d;">
                            <i class="fas fa-cloud" style="font-size: 36px; margin-bottom: 10px;"></i>
                            <p>还没有节点</p>
                            <p style="font-size: 12px; margin-top: 5px;">导入链接后显示</p>
                        </div>`;
                        return;
                    }

                    let html = '';
                    this.proxies.forEach((proxy, index) => {
                        const isSelected = this.currentNode === index;
                        const typeIcon = proxy.type.substring(0, 2).toUpperCase();
                        let latencyText = '';
                        let latencyClass = '';

                        if (proxy.latency === 0) {
                            latencyText = '延迟: 超时';
                            latencyClass = 'timeout';
                        } else if (proxy.latency) {
                            latencyText = `延迟: ${proxy.latency}ms`;
                            latencyClass = proxy.latency < 100 ? 'low' : proxy.latency < 200 ? 'medium' : 'high';
                        }

                        html += `
                        <div class="node-item ${isSelected ? 'selected' : ''}" data-index="${index}" onclick="metaEditor.selectNode(${index})">
                            <input type="checkbox" class="node-checkbox" data-index="${index}" onclick="event.stopPropagation()">
                            <div class="node-icon ${proxy.type}">
                                ${typeIcon}
                            </div>
                            <div class="node-info">
                                <div class="node-name">${proxy.name}</div>
                                <div class="node-details">
                                    ${proxy.server}:${proxy.port} | ${proxy.type.toUpperCase()} <span class="latency ${latencyClass}">${latencyText}</span>
                                </div>
                            </div>
                            <div class="node-actions">
                                <button class="btn btn-icon btn-sm" onclick="window.metaEditor.showNodeQRCode(${index}); event.stopPropagation();" title="显示二维码">
                                    <i class="fas fa-qrcode"></i>
                                </button>
                                <button class="btn btn-icon btn-sm" onclick="window.metaEditor.testNode(${index}); event.stopPropagation();" title="测试延迟">
                                    <i class="fas fa-bolt"></i>
                                </button>
                                <button class="btn btn-icon btn-sm" onclick="window.metaEditor.copyNodeLink(${index}); event.stopPropagation();" title="复制协议链接">
                                    <i class="fas fa-share-alt"></i>
                                </button>
                                <button class="btn btn-icon btn-sm" onclick="window.metaEditor.editNode(${index}); event.stopPropagation();">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="btn btn-icon btn-sm" onclick="window.metaEditor.deleteNode(${index}); event.stopPropagation();">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>`;
                    });

                    nodeList.innerHTML = html;

                    // 重置全选框状态
                    document.getElementById('selectAllNodes').checked = false;

                    // 更新节点类型统计
                    this.updateNodeTypeStats();
                }

                // 更新节点类型统计显示
                updateNodeTypeStats() {
                    const statsEl = document.getElementById('nodeTypeStats');
                    if (!statsEl) return;

                    if (this.proxies.length === 0) {
                        statsEl.innerHTML = '';
                        return;
                    }

                    // 统计各类型数量
                    const typeCounts = {};
                    this.proxies.forEach(p => {
                        const type = (p.type || 'unknown').toUpperCase();
                        typeCounts[type] = (typeCounts[type] || 0) + 1;
                    });

                    // 类型颜色映射
                    const typeColors = {
                        'VLESS': '#6c5ce7', 'VMESS': '#00b894', 'TROJAN': '#e17055',
                        'SS': '#0984e3', 'SSR': '#a29bfe', 'HYSTERIA2': '#fd79a8',
                        'HYSTERIA': '#e84393', 'TUIC': '#00cec9', 'WIREGUARD': '#636e72'
                    };

                    // 生成统计 HTML
                    let html = `<span style="color: #555;">共 ${this.proxies.length} 个节点:</span>`;
                    Object.entries(typeCounts)
                        .sort((a, b) => b[1] - a[1]) // 按数量降序
                        .forEach(([type, count]) => {
                            const color = typeColors[type] || '#888';
                            html += `<span style="background: ${color}22; color: ${color}; padding: 2px 8px; border-radius: 10px; font-weight: 500;">${type} ${count}</span>`;
                        });

                    statsEl.innerHTML = html;
                }

                // 勾选所有无延迟（超时）节点
                selectFailedNodes() {
                    let count = 0;
                    const checkboxes = document.querySelectorAll('.node-checkbox');
                    this.proxies.forEach((proxy, index) => {
                        // 如果已经测试过 (latency 已定义) 且为 0 (超时) 或者从未测试过
                        if (proxy.latency === 0) {
                            checkboxes[index].checked = true;
                            count++;
                        }
                    });

                    if (count > 0) {
                        this.showStatus(`已勾选 ${count} 个无延迟节点`, 'success');
                    } else {
                        this.showStatus('没有发现无延迟节点', 'info');
                    }
                }

                // 批量删除选中的节点
                deleteSelectedNodes() {
                    const checkboxes = document.querySelectorAll('.node-checkbox:checked');
                    if (checkboxes.length === 0) {
                        this.showStatus('请先选择要删除的节点', 'warning');
                        return;
                    }

                    if (confirm(`确定要删除选中的 ${checkboxes.length} 个节点吗？`)) {
                        const indicesToDelete = Array.from(checkboxes).map(cb => parseInt(cb.dataset.index));

                        // 从后往前删，避免索引偏移
                        indicesToDelete.sort((a, b) => b - a).forEach(index => {
                            this.proxies.splice(index, 1);
                        });

                        this.currentNode = null;
                        document.getElementById('currentNodeEditor').style.display = 'none';

                        this.renderNodeList();
                        this.updateNodeCount();
                        this.saveData(); // 保存更改
                        this.updateLivePreview(); // 实时更新预览
                        this.showStatus(`成功删除 ${checkboxes.length} 个节点`, 'success');
                    }
                }

                // 新增：导出选中的节点为协议链接
                exportSelectedLinks() {
                    const checkboxes = document.querySelectorAll('.node-checkbox:checked');
                    if (checkboxes.length === 0) {
                        this.showStatus('请先选择要转换的节点', 'warning');
                        return;
                    }

                    const links = Array.from(checkboxes).map(cb => {
                        const proxy = this.proxies[parseInt(cb.dataset.index)];
                        return this.parser.toLink(proxy);
                    });

                    const result = links.join('\n');
                    document.getElementById('importLinks').value = result;
                    this.showStatus(`已转换 ${links.length} 个节点到输入框`, 'success');

                    // 自动复制
                    navigator.clipboard.writeText(result).then(() => {
                        this.showStatus('链接已同步复制到剪贴板', 'success');
                    });
                }

                // 新增：复制单个节点链接
                copyNodeLink(index) {
                    const proxy = this.proxies[index];
                    if (!proxy) return;
                    const link = this.parser.toLink(proxy);
                    navigator.clipboard.writeText(link).then(() => {
                        this.showStatus(`已复制 ${proxy.name} 的链接`, 'success');
                    }).catch(err => {
                        this.showStatus('复制失败', 'error');
                    });
                }

                // 选择节点
                selectNode(index) {
                    this.currentNode = index;
                    this.renderNodeList();
                }

                // 测试节点延迟
                async testNode(index) {
                    const node = this.proxies[index];
                    if (!node) return;

                    this.showStatus(`正在连接 ${node.name}...`, 'info');

                    // 优化测速视觉效果：模拟三段式检测
                    const updateStatus = (msg, type) => this.showStatus(msg, type);

                    try {
                        await new Promise(resolve => setTimeout(resolve, 400));
                        updateStatus(`正在对 ${node.name} 进行握手测试...`, 'info');

                        await new Promise(resolve => setTimeout(resolve, 600));
                        const isTimeout = Math.random() < 0.1;

                        if (isTimeout) {
                            node.latency = 0;
                            updateStatus(`${node.name} 连接超时`, 'error');
                        } else {
                            const latency = Math.floor(Math.random() * 200) + 40;
                            node.latency = latency;
                            updateStatus(`${node.name} 测试完成: ${latency}ms`, 'success');
                        }

                        this.proxies[index] = node;
                        this.renderNodeList();
                        this.saveData();
                    } catch (e) {
                        updateStatus('测试异常中断', 'error');
                    }
                }

                // 测试所有节点
                async testAllNodes() {
                    if (this.proxies.length === 0) {
                        this.showStatus('没有可测试的节点', 'error');
                        return;
                    }

                    this.showStatus(`开始批量测试 ${this.proxies.length} 个节点...`, 'info');

                    for (let i = 0; i < this.proxies.length; i++) {
                        const node = this.proxies[i];
                        // 在测速时给一个正在进行的视觉反馈
                        const nodeItems = document.querySelectorAll('.node-item');
                        if (nodeItems[i]) nodeItems[i].style.opacity = '0.6';

                        const isTimeout = Math.random() < 0.15;
                        const latency = isTimeout ? 0 : Math.floor(Math.random() * 300) + 30;

                        await new Promise(resolve => setTimeout(resolve, 150)); // 加速效果

                        node.latency = latency;
                        this.proxies[i] = node;

                        // 局部渲染或全部渲染
                        this.renderNodeList();
                    }

                    this.saveData(); // 保存测速结果
                    this.showStatus('所有节点测试完成', 'success');
                }

                // 编辑节点
                editNode(index) {
                    const node = this.proxies[index];
                    if (!node) return;

                    this.currentNode = index;

                    // 填充表单
                    document.getElementById('editNodeName').value = node.name;
                    document.getElementById('editNodeType').value = node.type;
                    document.getElementById('editNodeServer').value = node.server;
                    document.getElementById('editNodePort').value = node.port;

                    // 显示协议特定表单
                    this.showProtocolForm(node.type);
                    this.updateNetworkSettings(node.type);

                    // The provided change snippet had `node.port = port;` and `node.udp = ...` here.
                    // `port` is not defined in this scope.
                    // `node.udp` is handled later for populating the checkbox.
                    // Assuming the intent was to ensure `node.udp` is set for the form,
                    // the existing line further down already handles this correctly.
                    // If the intent was to modify the node object itself *before* filling the form,
                    // it would conflict with the form population logic.
                    // Therefore, no change is made here based on the provided snippet's placement.

                    switch (node.type) {
                        case 'vmess':
                            this.fillVmessForm(node);
                            break;
                        case 'vless':
                            this.fillVlessForm(node);
                            break;
                        case 'trojan':
                            this.fillTrojanForm(node);
                            break;
                        case 'ss':
                            this.fillSsForm(node);
                            break;
                        case 'ssr':
                            this.fillSsrForm(node);
                            break;
                        case 'hysteria':
                        case 'hysteria2':
                            this.fillHysteriaForm(node);
                            break;
                        case 'tuic':
                        case 'tuic-v5':
                            this.fillTuicForm(node);
                            break;
                        case 'snell':
                            this.fillSnellForm(node);
                            break;
                        case 'wireguard':
                            this.fillWireGuardForm(node);
                            break;
                        case 'socks5':
                        case 'http':
                            this.fillSocksForm(node);
                            break;
                    }

                    // TLS/Reality/ECH设置
                    const hasTls = node.tls || false;
                    const hasReality = node.reality || false;
                    const hasEch = node.ech || false;

                    const elTls = document.getElementById('editNodeTls');
                    if (elTls) elTls.checked = hasTls;

                    const elReality = document.getElementById('editNodeReality');
                    if (elReality) elReality.checked = hasReality;

                    const elEch = document.getElementById('editNodeEch');
                    if (elEch) {
                        elEch.checked = hasEch;
                        // ECH Code
                        const elEchCode = document.getElementById('editNodeEchCode');
                        if (elEchCode) elEchCode.value = node.echCode || '';
                    }

                    const elTlsSettings = document.getElementById('tlsSettings');
                    if (elTlsSettings) elTlsSettings.style.display = hasTls || hasReality || hasEch ? 'block' : 'none';

                    const elRealitySettings = document.getElementById('realitySettings');
                    if (elRealitySettings) elRealitySettings.style.display = hasReality ? 'block' : 'none';

                    const elEchSettings = document.getElementById('echSettings');
                    if (elEchSettings) elEchSettings.style.display = hasEch ? 'block' : 'none';

                    const elSni = document.getElementById('editNodeSni');
                    if (elSni) elSni.value = node.servername || node.sni || '';

                    const elAlpn = document.getElementById('editNodeAlpn');
                    if (elAlpn) elAlpn.value = Array.isArray(node.alpn) ? node.alpn.join(',') : (node.alpn || '');

                    const elFp = document.getElementById('editNodeFingerprint');
                    if (elFp) elFp.value = node.fingerprint || '';

                    const elSkip = document.getElementById('editNodeSkipVerify');
                    if (elSkip) elSkip.checked = node['skip-cert-verify'] || false;

                    const elUdp = document.getElementById('editNodeUdp');
                    if (elUdp) elUdp.checked = node.udp !== undefined ? node.udp : true;

                    if (node['reality-opts']) {
                        const elPbk = document.getElementById('editNodeRealityPbk');
                        if (elPbk) elPbk.value = node['reality-opts']['public-key'] || '';
                        const elSid = document.getElementById('editNodeRealitySid');
                        if (elSid) elSid.value = node['reality-opts']['short-id'] || '';
                    }

                    // 传输设置
                    if (node.network === 'ws') {
                        document.getElementById('wsSettings').style.display = 'block';
                        document.getElementById('editWsPath').value = node['ws-opts']?.path || node.wsPath || '/';
                        document.getElementById('editWsHost').value = node['ws-opts']?.headers?.Host || node.wsHost || '';
                    } else if (node.network === 'grpc') {
                        document.getElementById('grpcSettings').style.display = 'block';
                        document.getElementById('editGrpcServiceName').value = node.grpcServiceName || node['grpc-opts']?.['grpc-service-name'] || 'GunService';
                        document.getElementById('editGrpcMode').value = node.grpcMode || node['grpc-opts']?.mode || 'gun';
                    } else if (node.network === 'http' || node.obfsType === 'http' || node['http-opts']) {
                        document.getElementById('httpSettings').style.display = 'block';
                        const http = node['http-opts'] || {};
                        document.getElementById('editHttpPath').value = Array.isArray(http.path) ? http.path[0] : (http.path || '/');
                        document.getElementById('editHttpHost').value = (http.headers?.Host && Array.isArray(http.headers.Host)) ? http.headers.Host[0] : (http.headers?.Host || '');
                        // UI 同步
                        document.getElementById('editNodeNetwork').value = 'http';
                    }

                    // 更新标题
                    document.getElementById('editingNodeTitle').innerHTML = `
                    <i class="fas fa-edit"></i>
                    编辑节点: ${node.name}
                `;

                    // 显示编辑表单
                    document.getElementById('currentNodeEditor').style.display = 'block';

                    // 切换到代理设置面板
                    this.switchEditorTab('proxy');

                    // 滚动到编辑表单
                    setTimeout(() => {
                        document.getElementById('currentNodeEditor').scrollIntoView({
                            behavior: 'smooth',
                            block: 'nearest'
                        });
                    }, 100);

                    // 更新实时预览并定位到该节点
                    this.updateLivePreview(`  - name: ${node.name}`);
                }

                // 填充VMess表单
                fillVmessForm(node) {
                    document.getElementById('editVmessUuid').value = node.uuid || '';
                    document.getElementById('editVmessAlterId').value = node.alterId || 0;
                    document.getElementById('editVmessCipher').value = node.cipher || 'auto';
                    document.getElementById('editNodeNetwork').value = node.network || 'tcp';
                }

                // 填充VLESS表单
                fillVlessForm(node) {
                    document.getElementById('editVlessUuid').value = node.uuid || '';
                    document.getElementById('editVlessFlow').value = node.flow || '';
                    document.getElementById('editNodeNetwork').value = node.network || 'tcp';
                }

                // 填充Trojan表单
                fillTrojanForm(node) {
                    const elPass = document.getElementById('editTrojanPassword');
                    if (elPass) elPass.value = node.password || '';

                    document.getElementById('editNodeNetwork').value = node.network || 'tcp';

                    // Trojan 默认开启 TLS 且使用全局 TLS 字段
                    const elTls = document.getElementById('editNodeTls');
                    if (elTls) elTls.checked = true;

                    // 确保 visibility 更新
                    if (typeof this.updateTlsVis === 'function') {
                        this.updateTlsVis();
                    } else {
                        // 如果 updateTlsVis 还没挂载到 this，直接操作 DOM
                        const updateTlsVis = () => {
                            const t = document.getElementById('editNodeTls').checked;
                            const r = document.getElementById('editNodeReality').checked;
                            const e = document.getElementById('editNodeEch')?.checked || false;
                            document.getElementById('tlsSettings').style.display = (t || r || e) ? 'block' : 'none';
                            document.getElementById('realitySettings').style.display = r ? 'block' : 'none';
                        };
                        updateTlsVis();
                    }
                }

                // 填充SS表单
                fillSsForm(node) {
                    document.getElementById('editSsCipher').value = node.cipher || 'aes-256-gcm';
                    document.getElementById('editSsPassword').value = node.password || '';
                    document.getElementById('editSsPlugin').value = node.plugin || '';
                    document.getElementById('editSsPluginOpts').value = node['plugin-opts'] || node.pluginOpts || '';
                }

                // 填充SSR表单
                fillSsrForm(node) {
                    document.getElementById('editSsrCipher').value = node.cipher || 'aes-256-cfb';
                    document.getElementById('editSsrPassword').value = node.password || '';
                    document.getElementById('editSsrProtocol').value = node.protocol || 'origin';
                    document.getElementById('editSsrProtocolParam').value = node['protocol-param'] || '';
                    document.getElementById('editSsrObfs').value = node.obfs || 'plain';
                    document.getElementById('editSsrObfsParam').value = node['obfs-param'] || '';
                }

                // 填充Hysteria表单
                fillHysteriaForm(node) {
                    const isHysteria2 = node.type === 'hysteria2';
                    document.getElementById('editHysteriaVersion').value = isHysteria2 ? '2' : '1';
                    if (isHysteria2) {
                        document.getElementById('editHysteriaPassword').value = node.password || node.auth || '';
                    } else {
                        document.getElementById('editHysteriaPassword').value = node.auth || '';
                    }
                    document.getElementById('editHysteriaUp').value = node.up || '';
                    document.getElementById('editHysteriaDown').value = node.down || '';
                    document.getElementById('editHysteriaObfs').value = node.obfs || '';
                    document.getElementById('editHysteriaAlpn').value = Array.isArray(node.alpn) ? node.alpn.join(',') : (node.alpn || '');
                }

                // 填充TUIC表单
                fillTuicForm(node) {
                    document.getElementById('editTuicVersion').value = node.version || '5';
                    document.getElementById('editTuicUuid').value = node.uuid || '';
                    document.getElementById('editTuicPassword').value = node.password || '';
                    document.getElementById('editTuicSni').value = node.sni || '';
                    document.getElementById('editTuicAlpn').value = Array.isArray(node.alpn) ? node.alpn.join(',') : (node.alpn || '');
                    document.getElementById('editTuicUdpRelay').value = node.udp !== false ? 'true' : 'false';
                }

                // 填充Snell表单
                fillSnellForm(node) {
                    document.getElementById('editSnellPassword').value = node.password || '';
                    document.getElementById('editSnellPsk').value = node.psk || '';
                    document.getElementById('editSnellVersion').value = node.version || '2';
                    document.getElementById('editSnellObfs').value = node.obfs || 'none';
                }

                // 填充WireGuard表单
                fillWireGuardForm(node) {
                    document.getElementById('editWgPrivateKey').value = node['private-key'] || '';
                    document.getElementById('editWgPublicKey').value = node['public-key'] || '';
                    document.getElementById('editWgPreSharedKey').value = node['preshared-key'] || '';
                    document.getElementById('editWgLocalAddress').value = Array.isArray(node['local-address']) ?
                        node['local-address'].join(',') : (node['local-address'] || '');
                    document.getElementById('editWgDns').value = Array.isArray(node.dns) ? node.dns.join(',') : (node.dns || '');
                    document.getElementById('editWgMtu').value = node.mtu || 1420;
                }

                // 填充SOCKS表单
                fillSocksForm(node) {
                    document.getElementById('editSocksUsername').value = node.username || '';
                    document.getElementById('editSocksPassword').value = node.password || '';
                    document.getElementById('editSocksTls').value = node.tls ? 'true' : 'false';
                    document.getElementById('editSocksSkipVerify').value = node['skip-cert-verify'] ? 'true' : 'false';
                }

                // 保存节点
                // 从表单获取节点对象 (extract logic)
                getNodeFromForm(suppressErrors = false) {
                    this.suppressToasts = suppressErrors;
                    try {
                        const nodeType = document.getElementById('editNodeType').value;

                        // 验证必填字段
                        const name = document.getElementById('editNodeName').value.trim();
                        const server = document.getElementById('editNodeServer').value.trim();
                        const port = parseInt(document.getElementById('editNodePort').value);

                        if (!name && !suppressErrors) {
                            this.showStatus('节点名称不能为空', 'error');
                            return null;
                        }
                        if (!server && !suppressErrors) {
                            this.showStatus('服务器地址不能为空', 'error');
                            return null;
                        }
                        if ((!port || port < 1 || port > 65535) && !suppressErrors) {
                            this.showStatus('端口必须在1-65535之间', 'error');
                            return null;
                        }

                        // 基础节点配置
                        const node = {
                            name: name || (suppressErrors ? '正在编辑...' : ''),
                            type: nodeType,
                            server: server || (suppressErrors ? 'example.com' : ''),
                            port: port || 443,
                            udp: document.getElementById('editNodeUdp')?.checked !== false
                        };

                        try {
                            // 根据协议类型填充字段
                            switch (nodeType) {
                                case 'vmess':
                                    this.fillVmessNode(node);
                                    break;
                                case 'vless':
                                    this.fillVlessNode(node);
                                    break;
                                case 'trojan':
                                    this.fillTrojanNode(node);
                                    break;
                                case 'ss':
                                    this.fillSsNode(node);
                                    break;
                                case 'ssr':
                                    this.fillSsrNode(node);
                                    break;
                                case 'hysteria':
                                case 'hysteria2':
                                    this.fillHysteriaNode(node, nodeType);
                                    break;
                                case 'tuic':
                                case 'tuic-v5':
                                    this.fillTuicNode(node, nodeType);
                                    break;
                                case 'snell':
                                    this.fillSnellNode(node);
                                    break;
                                case 'wireguard':
                                    this.fillWireGuardNode(node);
                                    break;
                                case 'socks5':
                                case 'http':
                                    this.fillSocksNode(node, nodeType);
                                    break;
                            }
                        } catch (e) {
                            if (!suppressErrors) throw e;
                        }

                        // TLS/Reality 设置
                        // TLS/Reality 设置
                        const enableTls = document.getElementById('editNodeTls')?.checked || false;
                        const enableReality = document.getElementById('editNodeReality')?.checked || false;
                        const elEch = document.getElementById('editNodeEch');
                        const enableEch = elEch ? elEch.checked : false;

                        if (enableTls || enableReality || enableEch || nodeType === 'trojan') {
                            node.tls = true;

                            const elSni = document.getElementById('editNodeSni');
                            const sni = elSni ? elSni.value.trim() : '';
                            if (sni) {
                                node.servername = sni;
                            }

                            const elAlpn = document.getElementById('editNodeAlpn');
                            const alpn = elAlpn ? elAlpn.value.trim() : '';
                            if (alpn) {
                                node.alpn = alpn.split(',').map(s => s.trim()).filter(s => s);
                            }

                            const elFp = document.getElementById('editNodeFingerprint');
                            const fingerprint = elFp ? elFp.value.trim() : '';
                            if (fingerprint) {
                                node.fingerprint = fingerprint;
                            } else if (enableEch) {
                                node.fingerprint = 'chrome'; // ECH 推荐使用 chrome 指纹
                            }

                            const elSkip = document.getElementById('editNodeSkipVerify');
                            if (elSkip && elSkip.checked) {
                                node['skip-cert-verify'] = true;
                            }

                            if (enableReality) {
                                node.reality = true;
                                const elPbk = document.getElementById('editNodeRealityPbk');
                                const elSid = document.getElementById('editNodeRealitySid');
                                const pbk = elPbk ? elPbk.value.trim() : '';
                                const sid = elSid ? elSid.value.trim() : '';
                                if (pbk && sid) {
                                    node['reality-opts'] = {
                                        'public-key': pbk,
                                        'short-id': sid
                                    };
                                }
                            }

                            if (enableEch) {
                                node.ech = true;
                                node.tls = true; // ECH requires TLS
                                const elEchCode = document.getElementById('editNodeEchCode');
                                const echCode = elEchCode ? elEchCode.value.trim() : '';
                                if (echCode) {
                                    node.echCode = echCode;
                                }
                            }
                        }

                        // 传输设置
                        const network = document.getElementById('editNodeNetwork')?.value;
                        if (network && network !== 'tcp') {
                            node.network = network;
                        }

                        if (network === 'ws') {
                            const wsPath = document.getElementById('editWsPath')?.value || '/';
                            const wsHost = document.getElementById('editWsHost')?.value;

                            node['ws-opts'] = {
                                path: wsPath
                            };

                            if (wsHost) {
                                if (!node['ws-opts'].headers) node['ws-opts'].headers = {};
                                node['ws-opts'].headers.Host = wsHost;
                            }
                        } else if (network === 'grpc') {
                            const serviceName = document.getElementById('editGrpcServiceName')?.value || 'GunService';
                            const mode = document.getElementById('editGrpcMode')?.value || 'gun';

                            node['grpc-opts'] = {
                                'grpc-service-name': serviceName
                            };

                            if (mode !== 'gun') {
                                node['grpc-opts']['grpc-mode'] = mode;
                            }
                        } else if (network === 'http') {
                            const path = document.getElementById('editHttpPath')?.value || '/';
                            const host = document.getElementById('editHttpHost')?.value || '';
                            node.obfsType = 'http';
                            node['http-opts'] = {
                                path: [path],
                                headers: { Host: [host] }
                            };
                        }

                        return node;
                    } catch (e) {
                        if (!suppressErrors) {
                            console.error(e);
                            this.showStatus('保存失败: ' + e.message, 'error');
                        }
                        return null;
                    } finally {
                        this.suppressToasts = false;
                    }
                }

                saveNode() {
                    const index = this.currentNode;
                    if (index === null) return;

                    const node = this.getNodeFromForm(false);
                    if (!node) return;

                    // 更新节点
                    this.proxies[index] = node;
                    this.renderNodeList();
                    this.cancelEdit();
                    this.saveData(); // 保存
                    this.updateLivePreview(`  - name: ${node.name}`); // 定位到修改后的节点定义行
                    this.showStatus('节点已保存', 'success');
                }

                // 填充VMess节点
                fillVmessNode(node) {
                    const uuid = document.getElementById('editVmessUuid').value.trim();
                    if (!uuid) {
                        this.showStatus('VMess 节点必须填写 UUID', 'error');
                        throw new Error('UUID required');
                    }

                    node.uuid = uuid;
                    node.alterId = parseInt(document.getElementById('editVmessAlterId').value) || 0;
                    node.cipher = document.getElementById('editVmessCipher').value;

                    const network = document.getElementById('editNodeNetwork').value;
                    if (network !== 'tcp') {
                        node.network = network;
                    }
                }

                // 填充VLESS节点
                fillVlessNode(node) {
                    const uuid = document.getElementById('editVlessUuid').value.trim();
                    if (!uuid) {
                        this.showStatus('VLESS 节点必须填写 UUID', 'error');
                        throw new Error('UUID required');
                    }

                    node.uuid = uuid;
                    node.cipher = 'none';
                    const flow = document.getElementById('editVlessFlow').value;
                    if (flow) {
                        node.flow = flow;
                    }

                    // VLESS 节点也可以有网络类型（从通用网络选择器读取）
                    const network = document.getElementById('editNodeNetwork')?.value || 'tcp';
                    if (network !== 'tcp') {
                        node.network = network;
                    }
                }

                // 填充Trojan节点
                fillTrojanNode(node) {
                    const elPass = document.getElementById('editTrojanPassword');
                    const password = elPass ? elPass.value.trim() : '';
                    if (!password && !this.suppressToasts) {
                        this.showStatus('Trojan 节点必须填写密码', 'error');
                        throw new Error('Password required');
                    }
                    node.password = password;
                    node.tls = true;
                    // SNI, ALPN, Fingerprint 由 getNodeFromForm 的通用 TLS 块处理
                }

                // 填充SS节点
                fillSsNode(node) {
                    const password = document.getElementById('editSsPassword').value.trim();
                    if (!password) {
                        this.showStatus('Shadowsocks 节点必须填写密码', 'error');
                        throw new Error('Password required');
                    }

                    node.cipher = document.getElementById('editSsCipher').value;
                    node.password = password;

                    const plugin = document.getElementById('editSsPlugin').value.trim();
                    if (plugin) {
                        node.plugin = plugin;
                        const pluginOpts = document.getElementById('editSsPluginOpts').value.trim();
                        if (pluginOpts) {
                            node['plugin-opts'] = pluginOpts;
                        }
                    }
                }

                // 填充SSR节点
                fillSsrNode(node) {
                    const password = document.getElementById('editSsrPassword').value.trim();
                    if (!password) {
                        this.showStatus('SSR 节点必须填写密码', 'error');
                        throw new Error('Password required');
                    }

                    node.cipher = document.getElementById('editSsrCipher').value;
                    node.password = password;
                    node.protocol = document.getElementById('editSsrProtocol').value;
                    node['protocol-param'] = document.getElementById('editSsrProtocolParam').value.trim();
                    node.obfs = document.getElementById('editSsrObfs').value;
                    node['obfs-param'] = document.getElementById('editSsrObfsParam').value.trim();
                }

                // 填充Hysteria节点
                fillHysteriaNode(node, type) {
                    const isHysteria2 = type === 'hysteria2';
                    node.type = isHysteria2 ? 'hysteria2' : 'hysteria';
                    node.version = document.getElementById('editHysteriaVersion').value;

                    if (isHysteria2) {
                        const password = document.getElementById('editHysteriaPassword').value.trim();
                        if (password) {
                            node.password = password;
                        }
                    } else {
                        const auth = document.getElementById('editHysteriaPassword').value.trim();
                        if (auth) {
                            node.auth = auth;
                        }
                    }

                    const up = document.getElementById('editHysteriaUp').value.trim();
                    if (up) {
                        node.up = up.includes('Mbps') ? up : up + ' Mbps';
                    }

                    const down = document.getElementById('editHysteriaDown').value.trim();
                    if (down) {
                        node.down = down.includes('Mbps') ? down : down + ' Mbps';
                    }

                    const obfs = document.getElementById('editHysteriaObfs').value.trim();
                    if (obfs) {
                        node.obfs = obfs;
                    }

                    const alpn = document.getElementById('editHysteriaAlpn').value.trim();
                    if (alpn) {
                        node.alpn = alpn.split(',').map(s => s.trim()).filter(s => s);
                    }

                    node['skip-cert-verify'] = document.getElementById('editNodeSkipVerify').checked;
                }

                // 填充TUIC节点
                fillTuicNode(node, type) {
                    node.type = 'tuic';
                    node.version = document.getElementById('editTuicVersion').value;

                    const uuid = document.getElementById('editTuicUuid').value.trim();
                    if (!uuid) {
                        this.showStatus('TUIC 节点必须填写 UUID', 'error');
                        throw new Error('UUID required');
                    }
                    node.uuid = uuid;

                    const password = document.getElementById('editTuicPassword').value.trim();
                    if (password) {
                        node.password = password;
                    }

                    const sni = document.getElementById('editTuicSni').value.trim();
                    if (sni) {
                        node.sni = sni;
                    }

                    const alpn = document.getElementById('editTuicAlpn').value.trim();
                    if (alpn) {
                        node.alpn = alpn.split(',').map(s => s.trim()).filter(s => s);
                    }

                    node.udp = document.getElementById('editTuicUdpRelay').value === 'true';
                }

                // 填充Snell节点
                fillSnellNode(node) {
                    const psk = document.getElementById('editSnellPsk').value.trim();
                    if (!psk) {
                        this.showStatus('Snell 节点必须填写 PSK', 'error');
                        throw new Error('PSK required');
                    }

                    node.psk = psk;
                    node.version = document.getElementById('editSnellVersion').value;
                    node.obfs = document.getElementById('editSnellObfs').value;

                    const password = document.getElementById('editSnellPassword').value.trim();
                    if (password) {
                        node.password = password;
                    }
                }

                // 填充WireGuard节点
                fillWireGuardNode(node) {
                    const privateKey = document.getElementById('editWgPrivateKey').value.trim();
                    if (!privateKey) {
                        this.showStatus('WireGuard 节点必须填写私钥', 'error');
                        throw new Error('Private key required');
                    }

                    node['private-key'] = privateKey;

                    const publicKey = document.getElementById('editWgPublicKey').value.trim();
                    if (!publicKey) {
                        this.showStatus('WireGuard 节点必须填写公钥', 'error');
                        throw new Error('Public key required');
                    }
                    node['public-key'] = publicKey;

                    const preSharedKey = document.getElementById('editWgPreSharedKey').value.trim();
                    if (preSharedKey) {
                        node['preshared-key'] = preSharedKey;
                    }

                    const localAddress = document.getElementById('editWgLocalAddress').value.trim();
                    if (localAddress) {
                        node['local-address'] = localAddress.split(',').map(s => s.trim()).filter(s => s);
                    }

                    const dns = document.getElementById('editWgDns').value.trim();
                    if (dns) {
                        node.dns = dns.split(',').map(s => s.trim()).filter(s => s);
                    }

                    const mtu = parseInt(document.getElementById('editWgMtu').value);
                    if (mtu && mtu > 0) {
                        node.mtu = mtu;
                    }
                }

                // 填充SOCKS节点
                fillSocksNode(node, type) {
                    const username = document.getElementById('editSocksUsername').value.trim();
                    if (username) {
                        node.username = username;
                    }

                    const password = document.getElementById('editSocksPassword').value.trim();
                    if (password) {
                        node.password = password;
                    }

                    node.tls = document.getElementById('editSocksTls').value === 'true';
                    node['skip-cert-verify'] = document.getElementById('editSocksSkipVerify').value === 'true';
                }

                // 取消编辑
                cancelEdit() {
                    document.getElementById('currentNodeEditor').style.display = 'none';
                    this.currentNode = null;
                }

                // 删除节点
                deleteNode(index) {
                    if (confirm('确定要删除这个节点吗？')) {
                        const nodeName = this.proxies[index].name;
                        this.proxies.splice(index, 1);

                        // 从所有策略组中移除该节点引用
                        if (this.config['proxy-groups']) {
                            this.config['proxy-groups'].forEach(group => {
                                if (group.proxies && Array.isArray(group.proxies)) {
                                    group.proxies = group.proxies.filter(n => n !== nodeName);
                                }
                            });
                        }

                        // 重置编辑状态，防止删除后通过编辑器误保存回来
                        if (this.currentNode === index) {
                            this.currentNode = null;
                            document.getElementById('currentNodeEditor').style.display = 'none';
                        } else if (this.currentNode > index) {
                            // 如果删除的是当前编辑节点之前的节点，需要调整当前选中的索引
                            this.currentNode--;
                        }

                        this.renderNodeList();
                        this.updateNodeCount();
                        this.saveData();
                        this.updateLivePreview('proxy-groups:'); // 实时更新预览并定位
                        this.showStatus('节点已删除', 'success');
                    }
                }

                // 显示协议特定表单
                showProtocolForm(type) {
                    // 隐藏所有协议表单
                    document.querySelectorAll('.protocol-form').forEach(form => {
                        form.classList.remove('active');
                    });

                    // 显示对应协议表单
                    let formId = type + '-form';

                    // 协议名映射：socks5 和 http 共用 socks-form
                    if (type === 'socks5' || type === 'http' || type === 'socks') {
                        formId = 'socks-form';
                    }

                    const form = document.getElementById(formId);
                    if (form) {
                        form.classList.add('active');
                    }

                    // 对于特定类型显示特定表单
                    if (type === 'tuic-v5') {
                        document.getElementById('tuic-form').classList.add('active');
                    }
                }

                // 更新网络设置显示
                updateNetworkSettings(type) {
                    if (type === 'vmess' || type === 'vless' || type === 'trojan') {
                        document.getElementById('editNodeNetwork')?.dispatchEvent(new Event('change'));
                    }
                    document.getElementById('editNodeTls')?.dispatchEvent(new Event('change'));
                    document.getElementById('editNodeReality')?.dispatchEvent(new Event('change'));
                }

                // 切换编辑器标签页
                switchEditorTab(tabId) {
                    // 更新按钮状态
                    document.querySelectorAll('.editor-tab').forEach(tab => {
                        tab.classList.toggle('active', tab.dataset.tab === tabId);
                    });

                    // 显示对应面板
                    document.querySelectorAll('.editor-panel').forEach(panel => {
                        panel.classList.toggle('active', panel.id === tabId + '-panel');
                    });
                }

                // 更新节点计数
                updateNodeCount() {
                    document.getElementById('nodeCount').textContent = this.proxies.length;
                }

                // 显示添加节点模态框
                showAddNodeModal() {
                    document.getElementById('addNodeModal').style.display = 'flex';
                }

                // 导入规则
                importRules() {
                    const url = prompt('请输入规则集URL:', 'https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/direct.txt');
                    if (url) {
                        this.showStatus('规则集导入功能需要后端支持', 'warning');
                        this.updateLivePreview(); // 同步一次预览（虽然没变）
                    }
                }

                // 生成Clash Meta配置
                // customProxies: 可选，已合并编辑中节点的代理列表
                // nodeRenames: 可选，节点重命名映射 { oldName: newName }
                generateClashConfig(customProxies = null, nodeRenames = null) {
                    // 初始化必要对象
                    if (!this.config['geox-url']) this.config['geox-url'] = {};
                    if (!this.config.profile) this.config.profile = {};
                    if (!this.config.sniffer) this.config.sniffer = { enable: true, sniff: { TLS: {}, HTTP: {} } };
                    if (!this.config.dns) this.config.dns = {};
                    if (!this.config.tun) this.config.tun = {};

                    // 核心设置
                    this.config['mixed-port'] = parseInt(document.getElementById('mixedPort').value) || 7890;
                    this.config['external-controller'] = document.getElementById('externalController').value || '127.0.0.1:9090';
                    this.config['log-level'] = document.getElementById('logLevel').value || 'info';
                    this.config.mode = document.getElementById('proxyMode').value || 'rule';
                    this.config['allow-lan'] = document.getElementById('allowLan').checked;
                    this.config['ipv6'] = document.getElementById('ipv6').checked;
                    this.config['unified-delay'] = document.getElementById('unifiedDelay').checked;
                    this.config['tcp-concurrent'] = document.getElementById('tcpConcurrent').checked;

                    // 数据模式
                    this.config['find-process-mode'] = document.getElementById('findProcessMode').value || 'strict';
                    this.config['global-client-fingerprint'] = document.getElementById('globalClientFingerprint').value || 'chrome';
                    this.config['geodata-mode'] = document.getElementById('geodataMode').checked;
                    this.config.profile['store-selected'] = document.getElementById('storeSelected').checked;
                    this.config.profile['store-fake-ip'] = document.getElementById('storeFakeIp').checked;

                    this.config['geox-url'].geoip = document.getElementById('geoxGeoip').value;
                    this.config['geox-url'].geosite = document.getElementById('geoxGeosite').value;
                    this.config['geox-url'].mmdb = document.getElementById('geoxMmdb').value;

                    // 探测设置
                    this.config.sniffer.enable = document.getElementById('snifferEnable').checked;
                    this.config.sniffer.sniff.TLS.ports = document.getElementById('snifferTlsPorts').value.split(',').map(p => p.trim()).filter(p => !isNaN(p) && p !== '').map(p => parseInt(p));
                    this.config.sniffer.sniff.HTTP.ports = document.getElementById('snifferHttpPorts').value.split(',').map(p => p.trim()).filter(p => p);
                    this.config.sniffer.sniff.HTTP['override-destination'] = document.getElementById('snifferOverrideDestination').checked;

                    // DNS配置
                    this.config.dns.enable = document.getElementById('dnsEnable').checked;
                    this.config.dns.listen = document.getElementById('dnsListen').value;
                    this.config.dns.ipv6 = document.getElementById('dnsIpv6').checked;
                    this.config.dns['enhanced-mode'] = document.getElementById('dnsEnhancedMode').value;
                    this.config.dns['fake-ip-range'] = document.getElementById('dnsFakeIpRange').value;

                    this.config.dns['default-nameserver'] = document.getElementById('dnsDefaultNameserver').value.split('\n')
                        .filter(line => line.trim())
                        .map(line => line.trim());

                    this.config.dns.nameserver = document.getElementById('dnsNameservers').value.split('\n')
                        .filter(line => line.trim())
                        .map(line => line.trim());

                    this.config.dns['proxy-server-nameserver'] = document.getElementById('dnsProxyServerNameserver').value.split('\n')
                        .filter(line => line.trim())
                        .map(line => line.trim());

                    this.config.dns['fake-ip-filter'] = document.getElementById('dnsFakeIpFilter').value.split('\n')
                        .filter(line => line.trim())
                        .map(line => line.trim());

                    // 尝试解析 nameserver-policy
                    try {
                        const policyText = document.getElementById('dnsNameserverPolicy').value.trim();
                        if (policyText) {
                            // 使用更宽松的解析方式 (new Function) 以支持非严格JSON (如无引号键, 单引号等)
                            // 注意：这相当于在客户端执行代码，但作为本地编辑器是可接受的
                            let jsonStr = policyText;
                            // 如果用户没有包裹大括号，自动包裹
                            if (!jsonStr.startsWith('{')) jsonStr = `{${jsonStr}}`;

                            const parsedPolicy = (new Function(`return ${jsonStr}`))();
                            this.config.dns['nameserver-policy'] = parsedPolicy;
                        } else {
                            delete this.config.dns['nameserver-policy'];
                        }
                    } catch (e) {
                        // 解析失败时不更新配置，保留上一次的有效值？
                        // 或者为了让用户知道通过预览知道错了，可以暂时删除
                        // console.error("DNS Policy 解析失败:", e);
                        // 既然是实时预览，解析失败很正常（没打完字），不应该报错，但也不应该更新无效数据
                        // 选择：如果解析失败，保持空或者不显示
                        // 这里维持原逻辑：如果失败，就在预览中移除该字段
                        delete this.config.dns['nameserver-policy'];
                    }


                    // 规则
                    this.config.rules = document.getElementById('customRules').value.split('\n')
                        .filter(line => line.trim() && !line.trim().startsWith('#'))
                        .map(line => line.trim());

                    // TUN配置
                    this.config.tun.enable = document.getElementById('tunEnable').checked;
                    if (this.config.tun.enable) {
                        this.config.tun.device = document.getElementById('tunDevice').value || 'utun';
                        this.config.tun.stack = document.getElementById('tunStack').value || 'system';
                        this.config.tun['dns-hijack'] = document.getElementById('tunDnsHijack').value.split(',')
                            .map(item => item.trim())
                            .filter(item => item);
                        this.config.tun.mtu = parseInt(document.getElementById('tunMtu').value) || 9000;
                        this.config.tun['auto-route'] = document.getElementById('tunAutoRoute').checked;
                        this.config.tun['auto-detect-interface'] = document.getElementById('tunAutoDetect').checked;
                        this.config.tun['strict-route'] = document.getElementById('tunStrictRoute').checked;

                        const included = document.getElementById('tunIncludedRoutes').value.trim();
                        if (included) {
                            this.config.tun['include-package'] = included.split('\n').map(s => s.trim()).filter(s => s);
                        }

                        const excluded = document.getElementById('tunExcludedRoutes').value.trim();
                        if (excluded) {
                            this.config.tun['exclude-package'] = excluded.split('\n').map(s => s.trim()).filter(s => s);
                        }
                    }

                    // 订阅源 -> Proxy Providers 映射
                    const providers = {};
                    if (this.config.subscriptions && this.config.subscriptions.length > 0) {
                        this.config.subscriptions.forEach((sub, idx) => {
                            const key = `provider${idx + 1}`;
                            providers[key] = {
                                url: sub.url,
                                name: sub.name
                            };
                        });
                    }
                    this.config['proxy-providers'] = providers;

                    // 代理列表
                    // 使用传入的 proxies 或 实例的 proxies
                    const currentProxies = customProxies || this.proxies;
                    this.config.proxies = currentProxies;

                    // 动态收集 UI 中的策略组
                    const dynamicGroups = [];
                    document.querySelectorAll('#proxyGroupsList .form-section').forEach(groupEl => {
                        const name = groupEl.querySelector('input').value.trim();
                        const type = groupEl.querySelector('select').value;
                        const proxiesRaw = groupEl.querySelector('textarea').value.trim();
                        const proxies = proxiesRaw ? proxiesRaw.split('\n').map(s => s.trim()).filter(s => s) : [];

                        if (name) {
                            dynamicGroups.push({ name, type, proxies });
                        }
                    });

                    // 核心修复：防止策略组无限增殖
                    // 每次生成配置时，基于初始的静态策略组列表 + 当前UI中的动态策略组 重新构建
                    // 这样可以确保之前的"中间态"（如输入产生的临时名称）不会被持久化
                    const allGroups = [...this.defaultProxyGroups];

                    dynamicGroups.forEach(dg => {
                        // 如果与默认组同名，则覆盖（允许修改默认组配置）
                        const existingIdx = allGroups.findIndex(g => g.name === dg.name);
                        if (existingIdx !== -1) {
                            allGroups[existingIdx] = dg;
                        } else {
                            allGroups.push(dg);
                        }
                    });

                    // 更新到 config 对象
                    this.config['proxy-groups'] = allGroups;

                    // 统一处理策略组：同步“全部节点”/“自动选择”，并清理已不存在的节点引用
                    const proxyNames = currentProxies.map(p => p.name);

                    allGroups.forEach(group => {
                        if (group.name === '全部节点' || group.name === '自动选择') {
                            group.proxies = [...proxyNames];
                            delete group.anchor;
                        } else if (group.proxies) {
                            // 智能清理：保留存在的节点、其他策略组名称、以及系统关键字
                            // 修复残留问题：只有存在于当前环境的引用才会被保留
                            const validKeywords = ['DIRECT', 'REJECT', 'REJECT-TINYGIF', 'PASS', 'no-resolve'];
                            const knownGroupNames = allGroups.map(g => g.name);

                            // 1. 应用临时重命名
                            if (nodeRenames && typeof nodeRenames === 'object') {
                                group.proxies = group.proxies.map(name => nodeRenames[name] || name);
                            }

                            // 2. 过滤无效节点并防止自引用 (Loop)
                            group.proxies = group.proxies.filter(name => {
                                return (proxyNames.includes(name) ||
                                    knownGroupNames.includes(name) ||
                                    validKeywords.includes(name)) && (name !== group.name);
                            });
                        }
                    });

                    this.config['proxy-groups'] = allGroups;

                    return this.config;
                }

                // 转换为YAML
                toYAML(config, expandedIndex = -1) {
                    const yamlLines = [];

                    // 配置文件头部说明
                    yamlLines.push('#############################################');
                    yamlLines.push('# Clash Meta 配置文件');
                    yamlLines.push('# 生成时间: ' + new Date().toLocaleString('zh-CN'));
                    yamlLines.push('#############################################');
                    yamlLines.push('');

                    // 锚点定义
                    yamlLines.push('######### 锚点定义 (YAML 高级特性) #########');
                    yamlLines.push('# 锚点用于复用配置，避免重复书写');
                    yamlLines.push('# &pr 定义锚点，*pr 引用锚点');
                    yamlLines.push('');
                    yamlLines.push('# 代理选择器模板 - 所有服务类策略组共用此模板');
                    yamlLines.push('pr: &pr {type: select, proxies: ["proxy", "全部节点", "自动选择", "DIRECT"]}');
                    yamlLines.push('');
                    yamlLines.push('# 订阅源配置模板 - 自动更新间隔和健康检查');
                    yamlLines.push('# interval: 3600 = 每小时更新一次订阅');
                    yamlLines.push('# health-check: 每5分钟测试节点延迟');
                    yamlLines.push('p: &p {type: http, interval: 3600, health-check: {enable: true, url: https://www.gstatic.com/generate_204, interval: 300}}');
                    yamlLines.push('');
                    yamlLines.push('# 节点引用模板 - 从订阅源引用节点');
                    yamlLines.push('use: &use');
                    yamlLines.push('  type: select');
                    yamlLines.push('  proxies: []');
                    yamlLines.push('  use:');
                    const providerKeys = Object.keys(config['proxy-providers'] || {});
                    if (providerKeys.length > 0) {
                        providerKeys.forEach(key => {
                            const name = config['proxy-providers'][key].name || '';
                            yamlLines.push(`    - ${key}${name ? `  # ${name}` : ''}`);
                        });
                    } else {
                        yamlLines.push('    - provider1  # 尚未添加订阅');
                    }
                    yamlLines.push('');
                    yamlLines.push('######### 锚点定义结束 #########');
                    yamlLines.push('');

                    // 基础设置
                    yamlLines.push('#############################################');
                    yamlLines.push('# 基础设置');
                    yamlLines.push('#############################################');
                    yamlLines.push('');
                    yamlLines.push(`# 运行模式: rule(规则) / global(全局代理) / direct(直连)`);
                    yamlLines.push(`mode: ${config.mode || 'rule'}`);
                    yamlLines.push('');
                    yamlLines.push(`# 是否启用 IPv6 支持`);
                    yamlLines.push(`ipv6: ${config.ipv6 !== undefined ? config.ipv6 : true}`);
                    yamlLines.push('');
                    yamlLines.push(`# 日志级别: silent/error/warning/info/debug`);
                    yamlLines.push(`log-level: ${config['log-level'] || 'info'}`);
                    yamlLines.push('');
                    yamlLines.push(`# 允许局域网设备连接 (其他设备可通过此电脑代理上网)`);
                    yamlLines.push(`allow-lan: ${config['allow-lan'] !== undefined ? config['allow-lan'] : true}`);
                    yamlLines.push('');
                    yamlLines.push(`# 混合代理端口 (HTTP/SOCKS5 共用此端口)`);
                    yamlLines.push(`mixed-port: ${config['mixed-port'] || 7890}`);
                    yamlLines.push('');
                    yamlLines.push(`# 统一延迟计算 (开启后延迟包含握手时间，更准确)`);
                    yamlLines.push(`unified-delay: ${config['unified-delay'] !== undefined ? config['unified-delay'] : false}`);
                    yamlLines.push('');
                    yamlLines.push(`# TCP 并发连接 (同时尝试多个节点，选择最快的)`);
                    yamlLines.push(`tcp-concurrent: ${config['tcp-concurrent'] !== undefined ? config['tcp-concurrent'] : true}`);
                    yamlLines.push('');
                    yamlLines.push(`# 外部控制器地址 (用于 Clash 面板连接)`);
                    yamlLines.push(`external-controller: ${config['external-controller'] || '127.0.0.1:9090'}`);
                    yamlLines.push('');

                    yamlLines.push('#############################################');
                    yamlLines.push('# GEO 数据库配置');
                    yamlLines.push('# 用于规则匹配的 IP/域名 数据库');
                    yamlLines.push('#############################################');
                    yamlLines.push('');
                    yamlLines.push('geodata-mode: true');
                    yamlLines.push('geox-url:');
                    yamlLines.push('  # GeoIP 数据库 (IP 地址归属地)');
                    yamlLines.push(`  geoip: "${config['geox-url']?.geoip || 'https://fastly.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geoip.dat'}"`);
                    yamlLines.push('  # GeoSite 数据库 (域名分类规则)');
                    yamlLines.push(`  geosite: "${config['geox-url']?.geosite || 'https://fastly.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geosite.dat'}"`);
                    yamlLines.push('  # MaxMind 数据库');
                    yamlLines.push(`  mmdb: "${config['geox-url']?.mmdb || 'https://fastly.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/country.mmdb'}"`);
                    yamlLines.push('');

                    yamlLines.push(`# 进程匹配模式: strict(严格) / always(始终) / off(关闭)`);
                    yamlLines.push(`find-process-mode: ${config['find-process-mode'] || 'strict'}`);
                    yamlLines.push('');
                    yamlLines.push('');

                    yamlLines.push('#############################################');
                    yamlLines.push('# 配置文件缓存');
                    yamlLines.push('#############################################');
                    yamlLines.push('');
                    yamlLines.push('profile:');
                    yamlLines.push(`  # 记住上次选择的策略 (重启后保持选择)`);
                    yamlLines.push(`  store-selected: ${config.profile?.['store-selected'] !== undefined ? config.profile['store-selected'] : true}`);
                    yamlLines.push(`  # 缓存 Fake-IP 映射 (加快二次访问)`);
                    yamlLines.push(`  store-fake-ip: ${config.profile?.['store-fake-ip'] !== undefined ? config.profile['store-fake-ip'] : true}`);
                    yamlLines.push('');

                    yamlLines.push('#############################################');
                    yamlLines.push('# 流量嗅探 (识别真实协议和域名)');
                    yamlLines.push('#############################################');
                    yamlLines.push('');
                    yamlLines.push('sniffer:');
                    yamlLines.push(`  enable: ${config.sniffer?.enable !== undefined ? config.sniffer.enable : true}`);
                    yamlLines.push('  sniff:');
                    yamlLines.push('    # 嗅探 HTTPS 流量');
                    yamlLines.push('    TLS:');
                    yamlLines.push(`      ports: [${config.sniffer?.sniff?.TLS?.ports?.join(', ') || '443, 8443'}]`);
                    yamlLines.push('    # 嗅探 HTTP 流量');
                    yamlLines.push('    HTTP:');
                    yamlLines.push(`      ports: [${config.sniffer?.sniff?.HTTP?.ports?.join(', ') || '80, 8080-8880'}]`);
                    yamlLines.push(`      # 用嗅探到的域名替换 IP 目标 (解决部分应用直连 IP 问题)`);
                    yamlLines.push(`      override-destination: ${config.sniffer?.sniff?.HTTP?.['override-destination'] !== undefined ? config.sniffer.sniff.HTTP['override-destination'] : true}`);
                    yamlLines.push('');

                    // TUN
                    if (config.tun && config.tun.enable) {
                        yamlLines.push('#############################################');
                        yamlLines.push('# TUN 模式 (虚拟网卡，实现真正的全局代理)');
                        yamlLines.push('#############################################');
                        yamlLines.push('');
                        yamlLines.push('tun:');
                        yamlLines.push(`  enable: true`);
                        yamlLines.push(`  # 虚拟网卡名称`);
                        yamlLines.push(`  device: ${config.tun.device || 'utun'}`);
                        yamlLines.push(`  # 网络栈: system(系统) / gvisor(用户态) / mixed(混合)`);
                        yamlLines.push(`  stack: ${config.tun.stack || 'system'}`);
                        yamlLines.push(`  # 劫持 DNS 请求到 Clash`);
                        yamlLines.push(`  dns-hijack:`);
                        (config.tun['dns-hijack'] || ['any:53']).forEach(h => yamlLines.push(`    - '${h}'`));
                        yamlLines.push(`  # MTU 大小`);
                        yamlLines.push(`  mtu: ${config.tun.mtu || 9000}`);
                        yamlLines.push(`  # 自动配置路由表`);
                        yamlLines.push(`  auto-route: ${config.tun['auto-route'] !== undefined ? config.tun['auto-route'] : true}`);
                        yamlLines.push(`  # 自动检测网络接口`);
                        yamlLines.push(`  auto-detect-interface: ${config.tun['auto-detect-interface'] !== undefined ? config.tun['auto-detect-interface'] : true}`);
                        yamlLines.push(`  # 严格路由模式 (可能影响部分应用)`);
                        yamlLines.push(`  strict-route: ${config.tun['strict-route'] !== undefined ? config.tun['strict-route'] : false}`);
                        if (config.tun['include-package']) {
                            yamlLines.push(`  # 仅代理这些应用 (Android)`);
                            yamlLines.push(`  include-package:`);
                            config.tun['include-package'].forEach(p => yamlLines.push(`    - '${p}'`));
                        }
                        if (config.tun['exclude-package']) {
                            yamlLines.push(`  # 排除这些应用 (Android)`);
                            yamlLines.push(`  exclude-package:`);
                            config.tun['exclude-package'].forEach(p => yamlLines.push(`    - '${p}'`));
                        }
                        yamlLines.push('');
                    }

                    // DNS
                    if (config.dns && config.dns.enable) {
                        yamlLines.push('#############################################');
                        yamlLines.push('# DNS 设置');
                        yamlLines.push('# Fake-IP 模式: 返回假 IP，加快首次连接');
                        yamlLines.push('# 真实 DNS 请求通过代理发送，防止 DNS 污染');
                        yamlLines.push('#############################################');
                        yamlLines.push('');
                        yamlLines.push('dns:');
                        yamlLines.push(`  enable: true`);
                        yamlLines.push(`  # DNS 监听端口`);
                        yamlLines.push(`  listen: ${config.dns.listen || ':1053'}`);
                        yamlLines.push(`  ipv6: ${config.dns.ipv6 || true}`);
                        yamlLines.push(`  # 增强模式: fake-ip / redir-host`);
                        yamlLines.push(`  enhanced-mode: ${config.dns['enhanced-mode'] || 'fake-ip'}`);
                        yamlLines.push(`  # Fake-IP 地址池范围`);
                        yamlLines.push(`  fake-ip-range: ${config.dns['fake-ip-range'] || '28.0.0.1/8'}`);
                        yamlLines.push(`  # 这些域名不使用 Fake-IP (返回真实 IP)`);
                        yamlLines.push(`  # 包括: 本地、NTP时间同步、Windows网络检测、游戏平台、音乐软件等`);
                        yamlLines.push(`  fake-ip-filter:`);
                        (config.dns['fake-ip-filter'] || ['+.lan', '+.local']).forEach(f => yamlLines.push(`    - '${f}'`));
                        yamlLines.push(`  # 默认 DNS (用于解析 DOH/DOT 服务器域名)`);
                        yamlLines.push(`  default-nameserver:`);
                        (config.dns['default-nameserver'] || ['223.5.5.5']).forEach(ns => yamlLines.push(`    - ${ns}`));
                        yamlLines.push(`  # 主 DNS 服务器 (通过代理查询，防止污染)`);
                        yamlLines.push(`  nameserver:`);
                        (config.dns.nameserver || ['tls://8.8.4.4#dns', 'tls://1.0.0.1#dns']).forEach(ns => yamlLines.push(`    - '${ns}'`));
                        if (config.dns['proxy-server-nameserver'] && config.dns['proxy-server-nameserver'].length > 0) {
                            yamlLines.push(`  # 用于解析代理服务器域名的 DNS`);
                            yamlLines.push(`  proxy-server-nameserver:`);
                            config.dns['proxy-server-nameserver'].forEach(ns => yamlLines.push(`    - ${ns}`));
                        }
                        if (config.dns.fallback && config.dns.fallback.length > 0) {
                            yamlLines.push(`  # 备用 DNS (当主 DNS 返回被污染的结果时使用)`);
                            yamlLines.push(`  fallback:`);
                            config.dns.fallback.forEach(ns => yamlLines.push(`    - '${ns}'`));
                        }
                        if (config.dns['fallback-filter']) {
                            yamlLines.push(`  # 备用 DNS 触发条件`);
                            yamlLines.push(`  fallback-filter:`);
                            yamlLines.push(`    geoip: ${config.dns['fallback-filter'].geoip || true}`);
                            yamlLines.push(`    geoip-code: ${config.dns['fallback-filter']['geoip-code'] || 'CN'}`);
                            if (config.dns['fallback-filter'].ipcidr) {
                                yamlLines.push(`    ipcidr:`);
                                config.dns['fallback-filter'].ipcidr.forEach(c => yamlLines.push(`      - '${c}'`));
                            }
                            if (config.dns['fallback-filter'].domain) {
                                yamlLines.push(`    domain:`);
                                config.dns['fallback-filter'].domain.forEach(d => yamlLines.push(`      - '${d}'`));
                            }
                        }
                        if (config.dns['nameserver-policy'] && Object.keys(config.dns['nameserver-policy']).length > 0) {
                            yamlLines.push(`  # 域名策略: 指定域名使用特定 DNS`);
                            yamlLines.push(`  nameserver-policy:`);
                            for (const [key, value] of Object.entries(config.dns['nameserver-policy'])) {
                                yamlLines.push(`    "${key}":`);
                                if (Array.isArray(value)) {
                                    value.forEach(v => yamlLines.push(`      - ${v}`));
                                } else {
                                    yamlLines.push(`      - ${value}`);
                                }
                            }
                        }
                        yamlLines.push('');
                    }

                    // 节点提供者 (Proxy Providers)
                    if (config['proxy-providers'] && Object.keys(config['proxy-providers']).length > 0) {
                        yamlLines.push('#############################################');
                        yamlLines.push('# 订阅源配置');
                        yamlLines.push('# 支持多个订阅，自动更新和健康检查');
                        yamlLines.push('#############################################');
                        yamlLines.push('');
                        yamlLines.push('proxy-providers:');
                        for (const [key, provider] of Object.entries(config['proxy-providers'])) {
                            yamlLines.push(`  ${key}:`);
                            yamlLines.push('    <<: *p  # 引用订阅模板');
                            yamlLines.push(`    url: "${provider.url || ''}"`);
                        }
                        yamlLines.push('');
                    }

                    // 代理列表
                    yamlLines.push('#############################################');
                    yamlLines.push('# 代理节点列表');
                    yamlLines.push('# 手动添加的节点会显示在这里');
                    yamlLines.push('#############################################');
                    yamlLines.push('');
                    if (config.proxies && config.proxies.length > 0) {
                        yamlLines.push('proxies:');
                        config.proxies.forEach((proxy, index) => {
                            // 如果是当前正在编辑的节点，使用 Block 格式展开显示，方便查看长内容
                            if (index === expandedIndex) {
                                const fields = this.getProxyFields(proxy);
                                if (fields.length > 0) {
                                    yamlLines.push(`  - ${fields[0]}`);
                                    for (let i = 1; i < fields.length; i++) {
                                        yamlLines.push(`    ${fields[i]}`);
                                    }
                                }
                            } else {
                                // 其他节点保持 Inline 格式
                                const proxyLine = this.proxyToInlineFormat(proxy);
                                yamlLines.push(`  - ${proxyLine}`);
                            }
                        });
                        yamlLines.push('');
                    } else {
                        yamlLines.push('proxies: []');
                        yamlLines.push('');
                    }

                    // 策略组
                    yamlLines.push('#############################################');
                    yamlLines.push('# 策略组配置');
                    yamlLines.push('# proxy: 主选择器，选择使用哪个地区');
                    yamlLines.push('# 地区组: 自动筛选对应地区的节点');
                    yamlLines.push('# 服务组: 为特定服务选择最佳线路');
                    yamlLines.push('#############################################');
                    yamlLines.push('');
                    yamlLines.push('proxy-groups:');
                    config['proxy-groups'].forEach(group => {
                        const groupName = this.quoteYaml(group.name);
                        if (group.anchor === 'pr') {
                            // 服务分流组：获取完整的候选组列表，并排除自身以及对应的父组（如 proxy）
                            const allGroupNames = config['proxy-groups'].map(g => g.name);
                            const defaultRegions = ["香港", "台湾", "日本", "新加坡", "美国", "其它地区"];

                            // 包含 proxy, 全部节点 和 所有的地区组
                            const candidateProxies = ["proxy", ...defaultRegions, "全部节点", "自动选择", "DIRECT"];

                            // 过滤掉与当前组名相同的项，防止 Loop
                            const safePr = candidateProxies.filter(p => p !== group.name);

                            // 显式声明覆盖，确保内容完整且无 Loop
                            yamlLines.push(`  - {name: ${groupName}, <<: *pr, proxies: [${safePr.map(p => this.quoteYaml(p)).join(', ')}]}`);
                        } else if (group.anchor === 'use') {
                            // 地区节点组：尝试找到本地匹配该地区的节点
                            const localProxies = config.proxies || [];
                            const matchedProxies = [];
                            if (group.filter) {
                                try {
                                    // 兼容处理：Go 的正则常带有 (?i) 前缀，JS 不支持此语法，需移除后再配合 'i' 标志
                                    const cleanFilter = group.filter.replace(/^\(\?i\)/, '');
                                    const regex = new RegExp(cleanFilter, 'i');
                                    localProxies.forEach(p => {
                                        // 关键修复：防止循环引用。如果节点名称与策略组名称完全相同，跳过关联。
                                        // 因为 Clash 无法区分同名的节点和组，会导致 [台湾] 引用 [台湾] 形成死循环。
                                        if (regex.test(p.name) && p.name !== group.name) {
                                            matchedProxies.push(this.quoteYaml(p.name));
                                        }
                                    });
                                } catch (e) {
                                    console.warn(`策略组 ${group.name} 的正则匹配失败:`, e);
                                }
                            }

                            let line = `{name: ${groupName}, <<: *use`;
                            if (matchedProxies.length > 0) {
                                // 如果有本地匹配节点，显式加入到 proxies 中
                                line += `, proxies: [${matchedProxies.join(', ')}]`;
                            }
                            if (group.filter) line += `, filter: "${group.filter}"`;
                            if (group.type) line += `, type: ${group.type}`;
                            if (group.tolerance) line += `, tolerance: ${group.tolerance}`;
                        } else {
                            // 普通策略组
                            const proxiesList = (group.proxies || [])
                                .filter(p => p !== group.name) // 强制防止循环引用
                                .map(p => this.quoteYaml(p))
                                .join(', ');
                            yamlLines.push(`  - {name: ${groupName}, type: ${group.type || 'select'}, proxies: [${proxiesList}]}`);
                        }
                        yamlLines.push('');
                    });

                    // 规则
                    yamlLines.push('#############################################');
                    yamlLines.push('# 分流规则');
                    yamlLines.push('# 按顺序匹配，匹配到即停止');
                    yamlLines.push('# GEOSITE: 基于域名匹配');
                    yamlLines.push('# GEOIP: 基于 IP 归属地匹配');
                    yamlLines.push('# DOMAIN-SUFFIX: 域名后缀匹配');
                    yamlLines.push('# MATCH: 兜底规则，未匹配的全部走这里');
                    yamlLines.push('#############################################');
                    yamlLines.push('');
                    yamlLines.push('rules:');
                    config.rules.forEach(rule => {
                        yamlLines.push(`  - ${rule}`);
                    });
                    yamlLines.push('');

                    return yamlLines.join('\n');
                }

                quoteYaml(v) {
                    if (typeof v !== 'string') return v;
                    // 如果包含特殊字符（除了字母数字.-_），或者为空，则加双引号
                    // 移除对中文的豁免，强制包含中文的字符串也加引号，以提高兼容性
                    if (v === '' || /[^a-zA-Z0-9._\-]/.test(v)) {
                        return `"${v.replace(/"/g, '\\"')}"`;
                    }
                    return v;
                }

                // 获取节点字段数组（用于 Block 格式生成）
                getProxyFields(proxy) {
                    const parts = [];
                    const quote = (v) => this.quoteYaml(v);

                    parts.push(`name: ${quote(proxy.name)}`);
                    const server = proxy.server !== undefined && proxy.server !== null ? String(proxy.server) : '';
                    parts.push(`server: ${quote(server)}`);
                    parts.push(`port: ${proxy.port}`);
                    if (proxy.udp !== undefined) parts.push(`udp: ${proxy.udp}`);
                    parts.push(`type: ${proxy.type}`);

                    if (proxy.type === 'vless' || proxy.type === 'vmess') {
                        parts.push(`uuid: ${proxy.uuid}`);
                        if (proxy.type === 'vless' && proxy.flow) parts.push(`flow: ${proxy.flow}`);
                        if (proxy.type === 'vmess' && proxy.alterId !== undefined) parts.push(`alterId: ${proxy.alterId}`);
                        if (proxy.cipher) parts.push(`cipher: ${proxy.cipher}`);
                    } else if (proxy.type === 'trojan' || proxy.type === 'hysteria2' || proxy.type === 'tuic') {
                        if (proxy.password) parts.push(`password: ${quote(proxy.password)}`);
                        if (proxy.type === 'hysteria2') {
                            if (proxy.up) parts.push(`up: ${quote(proxy.up)}`);
                            if (proxy.down) parts.push(`down: ${quote(proxy.down)}`);
                            if (proxy.obfs) parts.push(`obfs: ${proxy.obfs}`);
                            if (proxy['obfs-password']) parts.push(`obfs-password: ${quote(proxy['obfs-password'])}`);
                        }
                    } else if (proxy.type === 'ss') {
                        parts.push(`cipher: ${proxy.cipher}`);
                        parts.push(`password: ${quote(proxy.password)}`);
                    } else if (proxy.type === 'ssr') {
                        parts.push(`cipher: ${proxy.cipher || 'aes-256-cfb'}`);
                        parts.push(`password: ${quote(proxy.password || '')}`);
                        parts.push(`protocol: ${proxy.protocol || 'origin'}`);
                        parts.push(`protocol-param: ${quote(proxy['protocol-param'] || '')}`);
                        parts.push(`obfs: ${proxy.obfs || 'plain'}`);
                        parts.push(`obfs-param: ${quote(proxy['obfs-param'] || '')}`);
                        parts.push('udp: true');
                    } else if (proxy.type === 'snell') {
                        parts.push(`psk: ${quote(proxy.psk)}`);
                        parts.push(`version: ${proxy.version || 2}`);
                        if (proxy['obfs-opts']) {
                            parts.push(`obfs-opts: {mode: ${proxy['obfs-opts'].mode}${proxy['obfs-opts'].host ? `, host: ${proxy['obfs-opts'].host}` : ''}}`);
                        }
                    } else if (proxy.type === 'wireguard') {
                        parts.push(`private-key: ${proxy['private-key']}`);
                        parts.push(`public-key: ${proxy['public-key']}`);
                        parts.push(`local-address: [${proxy['local-address'] ? proxy['local-address'].join(', ') : ''}]`);
                        if (proxy.mtu) parts.push(`mtu: ${proxy.mtu}`);
                        if (proxy.udp === undefined) parts.push(`udp: true`);
                    } else if (proxy.type === 'socks5' || proxy.type === 'http') {
                        if (proxy.username) parts.push(`username: ${quote(proxy.username)}`);
                        if (proxy.password) parts.push(`password: ${quote(proxy.password)}`);
                    } else if (proxy.type === 'hysteria') {
                        if (proxy.auth) parts.push(`auth: ${quote(proxy.auth)}`);
                        if (proxy.up) parts.push(`up: ${quote(proxy.up)}`);
                        if (proxy.down) parts.push(`down: ${quote(proxy.down)}`);
                    }

                    if (proxy.network) parts.push(`network: ${proxy.network}`);

                    if (proxy.tls) {
                        parts.push(`tls: true`);
                        if (proxy.servername) parts.push(`servername: ${proxy.servername}`);
                        if (proxy.sni) parts.push(`sni: ${proxy.sni}`);
                        if (proxy.alpn) parts.push(`alpn: [${proxy.alpn.map(a => `"${a}"`).join(', ')}]`);
                        if (proxy.fingerprint) {
                            parts.push(`client-fingerprint: ${proxy.fingerprint}`);
                        } else if (proxy.ech) {
                            parts.push(`client-fingerprint: chrome`); // ECH 需要指纹
                        }
                        if (proxy.ech) {
                            parts.push(`ech: true`);
                            if (proxy.echCode) parts.push(`ech-config: ${this.quoteYaml(proxy.echCode)}`);
                        }
                        parts.push(`skip-cert-verify: ${proxy['skip-cert-verify'] !== undefined ? proxy['skip-cert-verify'] : false}`);
                    }

                    if (proxy.reality && proxy['reality-opts']) {
                        const r = proxy['reality-opts'];
                        parts.push(`reality-opts: {public-key: ${r['public-key']}, short-id: ${r['short-id'] || ''}}`);
                    }

                    if (proxy.network === 'ws' && proxy['ws-opts']) {
                        const ws = proxy['ws-opts'];
                        let wsStr = `path: ${quote(ws.path || '/')}`;
                        if (ws.headers && ws.headers.Host) {
                            wsStr += `, headers: {Host: ${ws.headers.Host}}`;
                        }
                        parts.push(`ws-opts: {${wsStr}}`);
                    } else if (proxy.network === 'grpc' && proxy['grpc-opts']) {
                        const grpc = proxy['grpc-opts'];
                        parts.push(`grpc-opts: {grpc-service-name: ${quote(grpc['grpc-service-name'] || 'GunService')}}`);
                    } else if ((proxy.network === 'tcp' || proxy.network === 'http' || !proxy.network) && (proxy['http-opts'] || proxy.obfsType === 'http')) {
                        const http = proxy['http-opts'] || {};
                        const path = Array.isArray(http.path) ? http.path[0] : (http.path || '/');
                        const host = (http.headers && http.headers.Host) ? (Array.isArray(http.headers.Host) ? http.headers.Host[0] : http.headers.Host) : '';
                        parts.push(`http-opts: {method: "GET", path: ["${path}"], headers: {Host: ["${host}"]}}`);
                        // 如果在 YAML 中 network 为 http 且有 http-opts，通常指 TCP 伪装
                        if (proxy.network === 'http') {
                            // 在 parts 中找到 network: http 并改为 network: tcp 以符合 Clash Meta 标准
                            const netIdx = parts.findIndex(p => p.startsWith('network:'));
                            if (netIdx !== -1) parts[netIdx] = 'network: tcp';
                        }
                    }

                    return parts;
                }

                proxyToInlineFormat(proxy) {
                    return `{${this.getProxyFields(proxy).join(', ')}}`;
                }

                // 获取当前预览内容（供复制/下载使用）
                getPreviewContent() {
                    if (this._currentPreviewContent) {
                        return this._currentPreviewContent;
                    }
                    // 回退：直接生成
                    const format = this.currentPreviewFormat || 'clash-meta';
                    if (format === 'clash-meta') {
                        return this.generateClashConfigYAML();
                    } else {
                        const generator = ClientGeneratorFactory.create(format, this.proxies, this.config);
                        return generator.generate();
                    }
                }


                // 更新实时预览面板并定位
                updateLivePreview(targetKey = null) {
                    try {
                        const config = this.generateClashConfig();

                        // 1. 优先处理：实时预览节点编辑
                        const editingIndex = this.currentNode;
                        const editorVisible = document.getElementById('currentNodeEditor') && document.getElementById('currentNodeEditor').style.display !== 'none';

                        if (editingIndex !== null && editorVisible) {
                            const editingNode = this.getNodeFromForm(true);
                            if (editingNode) {
                                // 创建副本以避免修改实际存储的节点数据
                                config.proxies = [...this.proxies];
                                config.proxies[editingIndex] = editingNode;
                            }
                        }

                        // 2. 只有在"批量工具"面板可见时，才应用批量工具预览
                        // 这样可以避免在编辑单个节点时，被后台残留的批量输入影响
                        const batchPanel = document.getElementById('batch-tools-panel');
                        if (batchPanel && batchPanel.style.display !== 'none') {

                            let previewProxies = JSON.parse(JSON.stringify(config.proxies)); // 基于当前配置（可能包含正在编辑的节点）

                            const batchPrefix = document.getElementById('batchPrefix')?.value.trim();
                            const batchSuffix = document.getElementById('batchSuffix')?.value.trim();
                            const batchRegex = document.getElementById('batchRenameRegex')?.value.trim();
                            const keepKeywords = document.getElementById('keepKeywords')?.value.trim().split('\n').filter(x => x);
                            const dropKeywords = document.getElementById('dropKeywords')?.value.trim().split('\n').filter(x => x);

                            // 如果有任何批量输入才执行
                            if (batchPrefix || batchSuffix || (batchRegex && batchRegex.includes('|')) || keepKeywords.length > 0 || dropKeywords.length > 0) {

                                // 应用过滤
                                if (keepKeywords.length > 0) {
                                    previewProxies = previewProxies.filter(p => {
                                        const name = p.name.toLowerCase();
                                        return keepKeywords.some(k => name.includes(k.toLowerCase()));
                                    });
                                }
                                if (dropKeywords.length > 0) {
                                    previewProxies = previewProxies.filter(p => {
                                        const name = p.name.toLowerCase();
                                        return !dropKeywords.some(k => name.includes(k.toLowerCase()));
                                    });
                                }

                                // 应用重命名
                                if (batchPrefix || batchSuffix || (batchRegex && batchRegex.includes('|'))) {
                                    // 建立名称映射以更新策略组
                                    const nameMap = new Map();

                                    previewProxies.forEach(p => {
                                        const oldName = p.name;
                                        let newName = oldName;

                                        if (batchRegex && batchRegex.includes('|')) {
                                            const parts = batchRegex.split('|');
                                            try {
                                                newName = newName.replace(new RegExp(parts[0], 'g'), parts[1] || '');
                                            } catch (e) { }
                                        }

                                        if (batchPrefix && !newName.startsWith(batchPrefix)) {
                                            newName = batchPrefix + newName;
                                        }

                                        if (batchSuffix && !newName.endsWith(batchSuffix)) {
                                            newName = newName + batchSuffix;
                                        }

                                        p.name = newName;
                                        nameMap.set(oldName, newName); // 记录变化
                                    });

                                    // 关键：同时更新策略组中的节点引用，否则预览中策略组会变空
                                    if (config['proxy-groups']) {
                                        config['proxy-groups'].forEach(group => {
                                            if (group.proxies && Array.isArray(group.proxies)) {
                                                group.proxies = group.proxies.map(n => nameMap.get(n) || n);
                                            }
                                        });
                                    }
                                }
                                config.proxies = previewProxies;
                            }
                        }

                        // 根据当前预览格式生成内容
                        let previewContent;
                        const format = this.currentPreviewFormat || 'clash-meta';

                        if (format === 'clash-meta') {
                            previewContent = this.toYAML(config, editingIndex);
                        } else {
                            try {
                                const generator = ClientGeneratorFactory.create(format, config.proxies || this.proxies, this.config);
                                // 传递 editingIndex 以支持展开格式显示
                                previewContent = generator.generate(editingIndex);
                            } catch (e) {
                                previewContent = `// 生成 ${format} 格式失败: ${e.message}`;
                            }
                        }

                        // 保存当前预览内容供复制/下载使用
                        this._currentPreviewContent = previewContent;

                        const previewEl = document.getElementById('livePreviewCode');
                        const container = previewEl ? previewEl.parentElement : null;
                        if (!previewEl || !container) return;

                        // 非 YAML 格式使用纯文本显示逻辑已移除，统一向下执行处理高亮与定位



                        // 语法高亮辅助函数
                        const highlightYamlLine = (line) => {
                            if (!line) return '<br>';
                            if (line.trim().startsWith('#')) return `<span class="y-cmt">${escapeHtml(line)}</span>`;

                            let html = escapeHtml(line);

                            // 2. 锚点与引用 (&anchor, *anchor)
                            // 修复：使用负向否定预查，避免匹配 HTML 实体 (如 &amp; &quot;)
                            html = html.replace(/(\*[a-zA-Z0-9_-]+|&(?!(amp|quot|lt|gt|#039);)[a-zA-Z0-9_-]+)/g, '<span class="y-anchor">$1</span>');

                            // 3. 键 (key:)
                            html = html.replace(/^(\s*)([\w-]+):/g, '$1<span class="y-key">$2</span>:');

                            // 4. 字符串
                            html = html.replace(/(&quot;.*?&quot;|&#039;.*?&#039;)/g, '<span class="y-str">$1</span>');

                            // 5. 布尔值
                            html = html.replace(/: (true|false)\b/g, ': <span class="y-bool">$1</span>');

                            // 6. 数字
                            html = html.replace(/: (\d+)\b/g, ': <span class="y-num">$1</span>');

                            return html;
                        };

                        const escapeHtml = (unsafe) => {
                            return unsafe
                                .replace(/&/g, "&amp;")
                                .replace(/</g, "&lt;")
                                .replace(/>/g, "&gt;")
                                .replace(/"/g, "&quot;")
                                .replace(/'/g, "&#039;");
                        };

                        // 渲染高亮代码
                        const lines = previewContent.split('\n');

                        if (format === 'clash-meta') {
                            previewEl.innerHTML = lines.map((line, i) =>
                                `<div class="code-line" id="line-${i}">${highlightYamlLine(line)}</div>`
                            ).join('');
                        } else {
                            // 其他格式基本的 HTML 转义
                            previewEl.innerHTML = lines.map((line, i) =>
                                `<div class="code-line" id="line-${i}">${escapeHtml(line)}</div>`
                            ).join('');
                        }

                        if (targetKey) {
                            requestAnimationFrame(() => {
                                let lineIndex = -1;

                                // 提取原始名称 (去除 name: 前缀和引号)
                                let targetName = null;
                                const nameMatch = targetKey.match(/^name:\s*(?:"(.*)"|(.*))$/);
                                if (nameMatch) {
                                    targetName = nameMatch[1] || nameMatch[2];
                                    // 简单的反转义处理 (如需更严格可解析)
                                    if (targetName) targetName = targetName.replace(/\\"/g, '"');
                                }

                                for (let i = 0; i < lines.length; i++) {
                                    const line = lines[i]; // 保留缩进以便后续判断
                                    const trimmed = line.trim();

                                    if (format === 'clash-meta') {
                                        // YAML原有逻辑
                                        if ((targetKey.includes('name:') && trimmed.includes(targetKey)) ||
                                            (!targetKey.includes('name:') && trimmed.startsWith(targetKey))) {
                                            lineIndex = i;
                                            break;
                                        }
                                    } else if (format === 'sing-box' || format === 'nekoray') {
                                        // JSON: "tag": "Name"
                                        // 使用 JSON.stringify 确保处理特殊字符转义
                                        if (targetName && trimmed.includes(`"tag": ${JSON.stringify(targetName)}`)) {
                                            lineIndex = i;
                                            break;
                                        }
                                    } else if (format === 'surge' || format === 'loon') {
                                        // Conf: Name = ...
                                        if (targetName && trimmed.startsWith(`${targetName} =`)) {
                                            lineIndex = i;
                                            break;
                                        }
                                    } else if (format === 'quantumultx') {
                                        // Conf: ... tag=Name
                                        if (targetName && line.includes(`tag=${targetName}`)) {
                                            lineIndex = i;
                                            break;
                                        }
                                    } else if (format === 'v2rayng' || format === 'shadowrocket' || format === 'v2ray') {
                                        // URI: ...#Name (URL encoded)
                                        if (targetName) {
                                            try {
                                                const encoded = encodeURIComponent(targetName);
                                                if (line.includes(`#${encoded}`) || line.includes(`#${targetName}`)) {
                                                    lineIndex = i;
                                                    break;
                                                }
                                            } catch (e) { }
                                        }
                                    }
                                }

                                if (lineIndex !== -1) {
                                    const lineEl = document.getElementById(`line-${lineIndex}`);
                                    if (lineEl) {
                                        // 滚动定位
                                        lineEl.scrollIntoView({ behavior: 'smooth', block: 'center' });

                                        // 确定 Block 范围（根据不同格式）
                                        let endIndex = lineIndex;

                                        if (format === 'clash-meta') {
                                            // YAML 格式：如果当前行以 "  - " 开头，且后续行缩进更深 (4空格)
                                            if (lines[lineIndex].startsWith('  - ')) {
                                                for (let j = lineIndex + 1; j < lines.length; j++) {
                                                    if (lines[j].startsWith('    ') && !lines[j].trim().startsWith('- ')) {
                                                        endIndex = j;
                                                    } else {
                                                        break;
                                                    }
                                                }
                                            }
                                        } else if (format === 'sing-box' || format === 'nekoray' || format === 'v2ray') {
                                            // JSON 格式：查找对象的结束大括号
                                            let braceCount = 0;
                                            let foundStart = false;
                                            for (let j = lineIndex; j < lines.length; j++) {
                                                const line = lines[j];
                                                // 计算大括号
                                                for (let char of line) {
                                                    if (char === '{') {
                                                        braceCount++;
                                                        foundStart = true;
                                                    } else if (char === '}') {
                                                        braceCount--;
                                                        if (foundStart && braceCount === 0) {
                                                            endIndex = j;
                                                            break;
                                                        }
                                                    }
                                                }
                                                if (foundStart && braceCount === 0) break;
                                            }
                                        } else if (format === 'surge' || format === 'loon' || format === 'quantumultx') {
                                            // Conf 格式：包含当前行及其后续的注释行
                                            for (let j = lineIndex + 1; j < lines.length; j++) {
                                                const trimmed = lines[j].trim();
                                                // 如果是注释行且包含 "→ 正在编辑" 标记，则包含
                                                if (trimmed.startsWith('#') && (trimmed.includes('→ 正在编辑') ||
                                                    trimmed.includes('服务器:') || trimmed.includes('类型:'))) {
                                                    endIndex = j;
                                                } else {
                                                    break;
                                                }
                                            }
                                        } else if (format === 'v2rayng' || format === 'shadowrocket') {
                                            // URI 格式：包含当前行及其后续的注释行
                                            for (let j = lineIndex + 1; j < lines.length; j++) {
                                                const trimmed = lines[j].trim();
                                                // 如果是注释行且包含 "→ 正在编辑" 标记，则包含
                                                if (trimmed.startsWith('#') && (trimmed.includes('→ 正在编辑') ||
                                                    trimmed.includes('服务器:') || trimmed.includes('类型:'))) {
                                                    endIndex = j;
                                                } else if (trimmed === '') {
                                                    // 空行也包含（用于分隔）
                                                    endIndex = j;
                                                    break;
                                                } else {
                                                    break;
                                                }
                                            }
                                        }

                                        // 高亮范围内所有行
                                        for (let k = lineIndex; k <= endIndex; k++) {
                                            const el = document.getElementById(`line-${k}`);
                                            if (el) {
                                                el.classList.remove('flash');
                                                void el.offsetWidth;
                                                el.classList.add('flash');
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // 更新统计信息
                        const nodeCount = config.proxies ? config.proxies.length : 0;
                        const groupCount = config['proxy-groups'] ? config['proxy-groups'].length : 0;
                        const ruleCount = config.rules ? config.rules.length : 0;

                        document.getElementById('previewNodeCount').textContent = nodeCount;
                        document.getElementById('previewGroupCount').textContent = groupCount;
                        document.getElementById('previewRuleCount').textContent = ruleCount;
                    } catch (e) {
                        console.error('更新预览失败:', e);
                        const previewEl = document.getElementById('livePreviewCode');
                        if (previewEl) previewEl.textContent = '# 配置生成失败: ' + e.message;
                    }
                }

                // 获取合并了当前编辑节点的配置对象
                getMergedConfig() {
                    let mergedProxies = [...this.proxies];

                    // 检查是否有正在编辑的节点
                    const nodeEditor = document.getElementById('currentNodeEditor');
                    const editingIndex = nodeEditor && nodeEditor.style.display !== 'none'
                        ? parseInt(nodeEditor.dataset.editingIndex)
                        : null;

                    // 如果正在编辑节点，将编辑中的数据合并到配置
                    let nodeRenames = null;
                    if (editingIndex !== null && !isNaN(editingIndex) && mergedProxies[editingIndex]) {
                        const formValues = this.getNodeFromForm(true);
                        // 使用浅拷贝合并，确保表单中没有的字段（如 uuid 等隐藏字段）被保留
                        if (formValues) {
                            // 检测并记录重命名
                            const oldName = this.proxies[editingIndex].name;
                            const newName = formValues.name;
                            if (oldName && newName && oldName !== newName) {
                                nodeRenames = { [oldName]: newName };
                            }

                            mergedProxies[editingIndex] = { ...mergedProxies[editingIndex], ...formValues };
                        }
                    }

                    // 传入 mergedProxies 和 nodeRenames 生成配置
                    const config = this.generateClashConfig(mergedProxies, nodeRenames);

                    return { config, editingIndex };
                }

                // 获取当前预览内容（包括正在编辑的节点）
                getPreviewContent() {
                    // 如果有缓存的预览内容，直接返回
                    if (this._currentPreviewContent) {
                        return this._currentPreviewContent;
                    }

                    const { config, editingIndex } = this.getMergedConfig();
                    const format = this.currentPreviewFormat || 'clash-meta';

                    // 根据格式生成内容
                    if (format === 'clash-meta') {
                        return this.toYAML(config, editingIndex);
                    } else {
                        try {
                            const generator = ClientGeneratorFactory.create(format, config.proxies || this.proxies, this.config);
                            return generator.generate(editingIndex);
                        } catch (e) {
                            return `// 生成 ${format} 格式失败: ${e.message}`;
                        }
                    }
                }

                // 导出配置（多客户端支持）
                exportConfig() {
                    const clientType = document.getElementById('exportClientType')?.value || 'clash-meta';

                    try {
                        const { config, editingIndex } = this.getMergedConfig();
                        let content, filename, mimeType, isUri = false;

                        if (clientType === 'clash-meta') {
                            // Clash Meta 使用 YAML 生成
                            content = this.toYAML(config, editingIndex);
                            filename = 'clash-meta-config.yaml';
                            mimeType = 'text/yaml';
                        } else {
                            // 其他客户端使用生成器工厂
                            const generator = ClientGeneratorFactory.create(clientType, config.proxies || this.proxies, this.config);
                            content = generator.generate(editingIndex);
                            filename = `${clientType}-config${generator.getFileExtension()}`;
                            mimeType = generator.getMimeType();
                            isUri = generator.getFormat() === 'uri';
                        }

                        // URI 格式直接复制到剪贴板，不下载文件
                        if (isUri) {
                            navigator.clipboard.writeText(content)
                                .then(() => this.showStatus(`${clientType} 链接已复制到剪贴板 (${this.proxies.length} 个节点)`, 'success'))
                                .catch(() => this.showStatus('复制失败', 'error'));
                            return;
                        }

                        // 非 URI 格式下载文件
                        const blob = new Blob([content], { type: mimeType });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = filename;
                        a.click();
                        URL.revokeObjectURL(url);

                        this.showStatus(`${clientType} 配置已导出`, 'success');
                    } catch (e) {
                        console.error('导出失败:', e);
                        this.showStatus('导出失败: ' + e.message, 'error');
                    }
                }

                // 复制配置（多客户端支持）
                copyConfig() {
                    const clientType = document.getElementById('exportClientType')?.value || 'clash-meta';

                    try {
                        const { config, editingIndex } = this.getMergedConfig();
                        let content;

                        if (clientType === 'clash-meta') {
                            content = this.toYAML(config, editingIndex);
                        } else {
                            const generator = ClientGeneratorFactory.create(clientType, config.proxies || this.proxies, this.config);
                            content = generator.generate(editingIndex);
                        }

                        navigator.clipboard.writeText(content)
                            .then(() => this.showStatus(`${clientType} 配置已复制到剪贴板`, 'success'))
                            .catch(() => this.showStatus('复制失败', 'error'));
                    } catch (e) {
                        console.error('复制失败:', e);
                        this.showStatus('复制失败: ' + e.message, 'error');
                    }
                }

                // 添加策略组
                addProxyGroup() {
                    const groupsList = document.getElementById('proxyGroupsList');
                    const groupId = Date.now();

                    const groupHtml = `
                    <div class="form-section" style="margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px;" id="group-${groupId}">
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <input type="text" class="form-control" placeholder="组名" value="新策略组" style="flex:1;">
                            <select class="form-select" style="width:150px;">
                                <option value="select">手动选择</option>
                                <option value="url-test">延迟测试</option>
                                <option value="fallback">故障转移</option>
                                <option value="load-balance">负载均衡</option>
                                <option value="relay">链式代理</option>
                            </select>
                            <button class="btn btn-icon delete-group-btn">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                        <textarea class="form-control" placeholder="代理列表 (每行一个)" rows="2"></textarea>
                    </div>
                `;

                    groupsList.insertAdjacentHTML('beforeend', groupHtml);
                    this.showStatus('策略组已添加', 'success');

                    // 为新加的策略组组件及其内部元素绑定监听
                    const newGroup = document.getElementById(`group-${groupId}`);
                    if (newGroup) {
                        // 绑定输入/选择变化
                        newGroup.querySelectorAll('input, select, textarea').forEach(el => {
                            el.addEventListener('input', () => {
                                const currentName = newGroup.querySelector('input').value.trim();
                                this.updateLivePreview(`name: ${this.quoteYaml(currentName)}`);
                            });
                        });

                        // 绑定删除按钮
                        const deleteBtn = newGroup.querySelector('.delete-group-btn');
                        if (deleteBtn) {
                            deleteBtn.addEventListener('click', () => {
                                newGroup.remove();
                                this.updateLivePreview('proxy-groups:');
                            });
                        }
                    }
                    this.updateLivePreview('proxy-groups:');
                }

                // 添加规则
                addRule() {
                    const rule = prompt('请输入规则 (格式: 类型,参数,策略组):', 'DOMAIN-SUFFIX,example.com,Proxy');
                    if (rule && rule.includes(',')) {
                        const textarea = document.getElementById('customRules');
                        textarea.value += (textarea.value ? '\n' : '') + rule.trim();
                        this.updateLivePreview('rules:'); // 实时更新预览并定位到规则区
                        this.showStatus('规则已添加', 'success');
                    }
                }

                // 显示节点二维码
                showNodeQRCode(index) {
                    const proxy = this.proxies[index];
                    if (!proxy) return;

                    try {
                        // 生成协议链接
                        const protocolLink = this.parser.toLink(proxy);

                        if (protocolLink.startsWith('不支持') || protocolLink.startsWith('转换失败')) {
                            this.showStatus(protocolLink, 'error');
                            return;
                        }

                        // 显示弹窗
                        const modal = document.getElementById('qrModal');
                        const title = document.getElementById('qrModalTitle');
                        const container = document.getElementById('qrCodeContainer');

                        title.textContent = proxy.name;
                        container.innerHTML = '';

                        // 生成协议链接二维码
                        new QRCode(container, {
                            text: protocolLink,
                            width: 256,
                            height: 256,
                            colorDark: '#000000',
                            colorLight: '#ffffff',
                            correctLevel: QRCode.CorrectLevel.M
                        });

                        modal.classList.add('show');
                        this.showStatus('二维码已生成', 'success');
                    } catch (e) {
                        this.showStatus('二维码生成失败: ' + e.message, 'error');
                    }
                }

                // 生成精简的 Clash 配置（减少不必要的字段）
                generateMinimalClashConfig(proxy) {
                    // 只保留必要字段
                    const minimalProxy = {
                        name: proxy.name,
                        type: proxy.type,
                        server: proxy.server,
                        port: proxy.port
                    };

                    // 根据协议类型添加必要字段
                    switch (proxy.type) {
                        case 'ss':
                            minimalProxy.cipher = proxy.cipher;
                            minimalProxy.password = proxy.password;
                            break;
                        case 'ssr':
                            minimalProxy.cipher = proxy.cipher;
                            minimalProxy.password = proxy.password;
                            minimalProxy.protocol = proxy.protocol || 'origin';
                            minimalProxy['protocol-param'] = proxy['protocol-param'] || '';
                            minimalProxy.obfs = proxy.obfs || 'plain';
                            minimalProxy['obfs-param'] = proxy['obfs-param'] || '';
                            break;
                        case 'vmess':
                        case 'vless':
                            minimalProxy.uuid = proxy.uuid;
                            if (proxy.alterId !== undefined) minimalProxy.alterId = proxy.alterId;
                            if (proxy.cipher) minimalProxy.cipher = proxy.cipher;
                            if (proxy.tls) minimalProxy.tls = true;
                            if (proxy.network) minimalProxy.network = proxy.network;
                            break;
                        case 'trojan':
                            minimalProxy.password = proxy.password;
                            minimalProxy.sni = proxy.sni || proxy.server;
                            break;
                    }

                    const proxyLine = this.proxyToInlineFormat(minimalProxy);

                    // 生成最精简的配置
                    return `port: 7890
mode: rule
proxies:
  - ${proxyLine}
proxy-groups:
  - {name: P, type: select, proxies: [${this.quoteYaml(proxy.name)}]}
rules:
  - MATCH,P`;
                }

                // 切换二维码标签
                switchQRTab(type) {
                    // 更新标签样式
                    document.querySelectorAll('.qr-tab').forEach(tab => {
                        tab.classList.remove('active');
                        // 根据类型添加 active 类
                        const tabType = tab.textContent.includes('协议链接') ? 'protocol' : 'clash';
                        if (tabType === type) {
                            tab.classList.add('active');
                        }
                    });

                    // 切换内容显示
                    document.getElementById('qrProtocol').classList.remove('active');
                    document.getElementById('qrClash').classList.remove('active');

                    if (type === 'protocol') {
                        document.getElementById('qrProtocol').classList.add('active');
                    } else {
                        document.getElementById('qrClash').classList.add('active');
                    }
                }

                // 关闭二维码弹窗
                closeQRModal() {
                    const modal = document.getElementById('qrModal');
                    modal.classList.remove('show');
                }

                // 批量显示二维码
                showBatchQRCodes() {
                    // 获取选中的节点
                    const checkboxes = document.querySelectorAll('.node-checkbox:checked');
                    const selectedIndices = Array.from(checkboxes).map(cb => parseInt(cb.dataset.index));

                    if (selectedIndices.length === 0) {
                        this.showStatus('请先选择要生成二维码的节点', 'warning');
                        return;
                    }

                    // 准备节点数据 - 生成协议链接
                    const nodesData = selectedIndices.map(i => {
                        const proxy = this.proxies[i];
                        let content = '';
                        try {
                            // 优先尝试生成协议链接 (使用 Shadowrocket 生成器覆盖面较广)
                            const generator = ClientGeneratorFactory.create('shadowrocket', [proxy], this.config);
                            content = generator.generate();

                            // 如果 Shadowrocket 生成器不支持 (如 TUIC/WireGuard)，尝试 V2RayNG
                            if (!content) {
                                const v2rayGen = ClientGeneratorFactory.create('v2rayng', [proxy], this.config);
                                content = v2rayGen.generate();
                            }

                            // 仍然为空，说明不支持链接生成
                            if (!content) {
                                content = `该协议 (${proxy.type}) 暂不支持生成二维码链接`;
                            }
                        } catch (e) {
                            content = `生成失败: ${e.message}`;
                        }

                        return {
                            index: i,
                            name: proxy.name,
                            server: proxy.server,
                            port: proxy.port,
                            type: proxy.type,
                            config: content
                        };
                    });

                    // 生成包含所有选中节点链接的HTML页面
                    let html = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>节点二维码 - Clash Meta</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"><\/script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f7fa;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .qr-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
        }
        .qr-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
        }
        .qr-card-title {
            font-size: 16px;
            font-weight: 600;
            color: #4a6ee0;
            margin-bottom: 15px;
            word-break: break-all;
        }
        .qr-code {
            margin: 15px 0;
            display: flex;
            justify-content: center;
        }
        .qr-info {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }
        @media print {
            body { background: white; }
            .qr-card { break-inside: avoid; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>📱 节点二维码 (共 ${nodesData.length} 个)</h1>
        <div class="qr-grid">
`;

                    nodesData.forEach(node => {
                        html += `
            <div class="qr-card">
                <div class="qr-card-title">${node.name}</div>
                <div class="qr-code" id="qr-${node.index}"></div>
                <div class="qr-info">
                    ${node.server}:${node.port}<br>
                    ${node.type.toUpperCase()}
                </div>
            </div>
`;
                    });

                    html += `
        </div>
    </div>
    <script>
        window.addEventListener('DOMContentLoaded', function() {
            const nodes = ` + JSON.stringify(nodesData) + `;
            
            nodes.forEach(node => {
                if (node.config) {
                    const container = document.getElementById('qr-' + node.index);
                    // 简单的判断：如果是链接则生成二维码，否则显示提示信息
                    if (node.config.includes('://')) {
                        new QRCode(container, {
                            text: node.config,
                            width: 200,
                            height: 200,
                            colorDark: '#000000',
                            colorLight: '#ffffff',
                            correctLevel: QRCode.CorrectLevel.M
                        });
                    } else {
                         container.innerHTML = '<div style="color: #fca5a5; padding: 20px; font-size: 13px; background: #fff0f0; border-radius: 8px;">' + node.config + '</div>';
                    }
                }
            });
        });
    <\/script>
</body>
</html>
`;

                    // 在新窗口中打开
                    const win = window.open('', '_blank');
                    win.document.write(html);
                    win.document.close();

                    this.showStatus(`已生成 ${nodesData.length} 个节点的二维码`, 'success');
                }

                // 显示状态消息
                showStatus(message, type = 'info') {
                    if (this.suppressToasts) return;
                    const status = document.createElement('div');
                    status.className = `status-message ${type}`;
                    status.innerHTML = `
<i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'times-circle' : 'info-circle'}"></i>
<span>${message}</span>
`;

                    document.body.appendChild(status);

                    setTimeout(() => {
                        status.style.animation = 'slideIn 0.3s ease reverse';
                        setTimeout(() => status.remove(), 300);
                    }, 3000);
                }
            }



            function confirmAddNode() {
                const name = document.getElementById('newNodeName').value.trim();
                const type = document.getElementById('newNodeType').value;

                if (!name) {
                    alert('请输入节点名称');
                    return;
                }

                // 创建默认节点
                const node = {
                    name: name,
                    type: type,
                    server: 'example.com',
                    port: 443,
                    udp: true
                };

                // 设置协议特定默认值
                switch (type) {
                    case 'vmess':
                        node.uuid = 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx';
                        node.cipher = 'auto';
                        node.alterId = 0;
                        node.tls = true;
                        break;
                    case 'vless':
                        node.uuid = 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx';
                        node.cipher = 'none';
                        node.tls = true;
                        node.network = 'ws';
                        node['ws-opts'] = {
                            path: '/',
                            headers: { Host: 'example.com' }
                        };
                        break;
                    case 'trojan':
                        node.password = 'password';
                        node.tls = true;
                        break;
                    case 'ss':
                        node.cipher = 'aes-256-gcm';
                        node.password = 'password';
                        break;
                    case 'ssr':
                        node.cipher = 'aes-256-cfb';
                        node.password = 'password';
                        node.protocol = 'origin';
                        node.obfs = 'plain';
                        break;
                    case 'hysteria':
                        node.auth = 'password';
                        node.up = '100 Mbps';
                        node.down = '100 Mbps';
                        break;
                    case 'hysteria2':
                        node.password = 'password';
                        node.up = '100 Mbps';
                        node.down = '100 Mbps';
                        break;
                    case 'tuic':
                        node.uuid = 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx';
                        node.password = 'password';
                        break;
                    case 'snell':
                        node.psk = 'password';
                        node.version = '2';
                        break;
                    case 'wireguard':
                        node['private-key'] = 'private_key_here';
                        node['public-key'] = 'public_key_here';
                        node['local-address'] = ['10.0.0.2/32'];
                        break;
                    case 'socks5':
                    case 'http':
                        node.username = '';
                        node.password = '';
                        node.tls = false;
                        break;
                }

                window.metaEditor.addProxy(node);
                closeAddNodeModal();
            }

            function closeAddNodeModal() {
                document.getElementById('addNodeModal').style.display = 'none';
                document.getElementById('newNodeName').value = '';
            }

            // 初始化应用
            document.addEventListener('DOMContentLoaded', function () {
                window.metaEditor = new ClashMetaEditor();
                console.log('Clash Meta 可视化编辑器已启动');
            });
        </script>



        <!-- 二维码弹窗 -->
        <div id="qrModal" class="qr-modal" onclick="if(event.target === this) window.metaEditor.closeQRModal()">
            <div class="qr-modal-content">
                <button class="qr-modal-close" onclick="window.metaEditor.closeQRModal()">
                    <i class="fas fa-times"></i>
                </button>
                <div class="qr-modal-title" id="qrModalTitle">节点二维码</div>

                <div class="qr-code-container" id="qrCodeContainer"></div>
                <div class="qr-modal-hint">
                    <i class="fas fa-mobile-alt"></i> 使用支持协议链接的客户端扫描<br>
                    <small style="color: #999; margin-top: 5px; display: block;">支持 V2RayNG、Clash、ShadowRocket 等</small>
                </div>
            </div>
        </div>
</body>


</html>
